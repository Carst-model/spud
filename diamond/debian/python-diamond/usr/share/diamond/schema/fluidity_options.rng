<?xml version="1.0" encoding="UTF-8"?>
<grammar xmlns:a="http://relaxng.org/ns/compatibility/annotations/1.0" xmlns="http://relaxng.org/ns/structure/1.0" datatypeLibrary="http://www.w3.org/2001/XMLSchema-datatypes">
  <start>
    <element name="fluidity_options">
      <a:documentation>The root node of the options dictionary.</a:documentation>
      <element name="simulation_name">
        <a:documentation>Model output files are named according to the simulation name, e.g. [simulation_name]_0.vtu. Non-standard characters in the simulation name should be avoided.</a:documentation>
        <ref name="anystring"/>
      </element>
      <element name="problem_type">
        <a:documentation>Option problem_type does not change the tree.  It is just used for options checking.</a:documentation>
        <element name="string_value">
          <!--
            Lines is a hint to the gui about the size of the text box.
            It is not an enforced limit on string length.
          -->
          <attribute name="lines">
            <value>1</value>
          </attribute>
          <choice>
            <value>fluids</value>
            <value>oceans</value>
            <value>solids</value>
            <value>multimaterial</value>
            <value>multiphase</value>
            <value>radiation</value>
          </choice>
        </element>
        <ref name="comment"/>
      </element>
      <element name="geometry">
        <a:documentation>Options dealing with the specification of geometry</a:documentation>
        <element name="dimension">
          <a:documentation>Dimension of the problem.
&lt;b&gt;This can only be set once&lt;/b&gt;</a:documentation>
          <attribute name="replaces">
            <value>NDIM</value>
          </attribute>
          <element name="integer_value">
            <attribute name="rank">
              <value>0</value>
            </attribute>
            <choice>
              <value>3</value>
              <value>2</value>
            </choice>
          </element>
        </element>
        <element name="mesh">
          <a:documentation>The position mesh</a:documentation>
          <attribute name="name">
            <value>CoordinateMesh</value>
          </attribute>
          <ref name="mesh_info"/>
        </element>
        <element name="mesh">
          <a:documentation>The velocity mesh</a:documentation>
          <attribute name="name">
            <value>VelocityMesh</value>
          </attribute>
          <ref name="mesh_info"/>
        </element>
        <element name="mesh">
          <a:documentation>The pressure mesh</a:documentation>
          <attribute name="name">
            <value>PressureMesh</value>
          </attribute>
          <ref name="mesh_info"/>
        </element>
        <zeroOrMore>
          <element name="mesh">
            <attribute name="name">
              <data type="string"/>
            </attribute>
            <ref name="mesh_info"/>
          </element>
        </zeroOrMore>
        <element name="quadrature">
          <a:documentation>Quadrature</a:documentation>
          <element name="degree">
            <a:documentation>Quadrature degree
note: this specifies the degree of quadrature not the number of gauss points</a:documentation>
            <attribute name="replaces">
              <value>NGI</value>
            </attribute>
            <ref name="integer"/>
          </element>
          <optional>
            <element name="surface_degree">
              <a:documentation>Surface quadrature degree
note: this specifies the degree of surface quadrature not the number of surface gauss points</a:documentation>
              <attribute name="replaces">
                <value>SNGI</value>
              </attribute>
              <ref name="integer"/>
            </element>
          </optional>
          <optional>
            <element name="controlvolume_surface_degree">
              <a:documentation>**UNDER TESTING**
Sets the degree of quadrature on each quadrilateral face of the control volume.
Only affects control volume discretisations using the new control volume shape function library.
Defaults to 1 if unselected which is the same as old behaviour.</a:documentation>
              <ref name="integer"/>
            </element>
          </optional>
        </element>
        <optional>
          <element name="spherical_earth">
            <a:documentation>Options specifying that the problem is on the surface of the sphere.</a:documentation>
            <attribute name="replaces">
              <value>ISPHERE</value>
            </attribute>
            <ref name="integer"/>
          </element>
        </optional>
        <optional>
          <element name="ocean_boundaries">
            <a:documentation>Options specifying the top surface and bottom of the domain
used in various ocean calculations.</a:documentation>
            <element name="top_surface_ids">
              <a:documentation>Specify the surface ids that make up the top of the domain,
i.e. the free surface or rigid lid.</a:documentation>
              <ref name="integer_vector"/>
            </element>
            <element name="bottom_surface_ids">
              <a:documentation>Specify the surface ids that make up the bottom.</a:documentation>
              <ref name="integer_vector"/>
            </element>
            <element name="scalar_field">
              <a:documentation>Diagnostic field giving the distance to the top surface.</a:documentation>
              <attribute name="rank">
                <value>0</value>
              </attribute>
              <attribute name="name">
                <value>DistanceToTop</value>
              </attribute>
              <element name="diagnostic">
                <element name="mesh">
                  <attribute name="name">
                    <value>CoordinateMesh</value>
                  </attribute>
                </element>
                <ref name="diagnostic_scalar_field"/>
              </element>
            </element>
            <element name="scalar_field">
              <a:documentation>Diagnostic field giving the distance to ocean bottom.</a:documentation>
              <attribute name="rank">
                <value>0</value>
              </attribute>
              <attribute name="name">
                <value>DistanceToBottom</value>
              </attribute>
              <element name="diagnostic">
                <element name="mesh">
                  <attribute name="name">
                    <value>CoordinateMesh</value>
                  </attribute>
                </element>
                <ref name="diagnostic_scalar_field"/>
              </element>
            </element>
          </element>
        </optional>
      </element>
      <element name="io">
        <a:documentation>Input/output options</a:documentation>
        <element name="dump_format">
          <a:documentation>Format for dump files. Choose from fluidity dumpfile or vtk.</a:documentation>
          <element name="string_value">
            <choice>
              <value>fluidity dumpfile</value>
              <value>vtk</value>
            </choice>
          </element>
        </element>
        <choice>
          <element name="dump_period">
            <a:documentation>Period between dumps in time units.
Specifies the period between each dump of the solution to disk.
A value of 0.0 indicates that there would be a dump at every timestep.</a:documentation>
            <attribute name="replaces">
              <value>TIMDUM</value>
            </attribute>
            <ref name="real"/>
          </element>
          <element name="dump_period_in_timesteps">
            <a:documentation>Dump period, in timesteps.
Specifies the number of timesteps between each dump of the solution to disk.
A value of 0 indicates a dump at every timestep.</a:documentation>
            <ref name="integer"/>
          </element>
        </choice>
        <optional>
          <!-- every CPUDUM seconds write results to disc. -->
          <element name="cpu_dump_period">
            <a:documentation>This is usually disabled.</a:documentation>
            <attribute name="replaces">
              <value>CPUDUM</value>
            </attribute>
            <ref name="real"/>
          </element>
        </optional>
        <optional>
          <element name="wall_time_dump_period">
            <a:documentation>The period between dumps in walltime seconds. This is usually disabled.</a:documentation>
            <attribute name="replaces">
              <value>WTIDUM</value>
            </attribute>
            <ref name="real"/>
          </element>
        </optional>
        <optional>
          <element name="max_dump_file_count">
            <a:documentation>Number of dumps before we overwrite previous dumps.</a:documentation>
            <attribute name="replaces">
              <value>DUMSAV</value>
            </attribute>
            <ref name="integer"/>
          </element>
        </optional>
        <choice>
          <element name="output_mesh">
            <a:documentation>The mesh on to which all the fields will be interpolated for VTK output.</a:documentation>
            <attribute name="name">
              <value>VelocityMesh</value>
            </attribute>
          </element>
          <element name="output_mesh">
            <a:documentation>The mesh on to which all the fields will be interpolated for VTK output.</a:documentation>
            <attribute name="name">
              <data type="string"/>
            </attribute>
          </element>
        </choice>
        <optional>
          <element name="convergence">
            <optional>
              <element name="convergence_file">
                <a:documentation>Whether to enable the creation of a convergence file, giving details
of the convergence of each field over the global nonlinear iteration loop.</a:documentation>
                <ref name="comment"/>
              </element>
            </optional>
            <optional>
              <element name="convergence_vtus">
                <a:documentation>Write state to a vtu on every iteration.
This is a useful debugging tool if things are not converging.
To prevent an excessive number of files being accumulated previous
timestep files will be overwritten hence it is best to use
in conjunction with /timestepping/nonlinear_iterations/terminate_if_not_converged</a:documentation>
                <ref name="comment"/>
              </element>
            </optional>
          </element>
        </optional>
        <optional>
          <element name="s_file">
            <a:documentation>Whether to enable the creation of a model .s file (old style Fluidity study file)

See http://amcg.ese.ic.ac.uk/index.php?title=Local:Fluidity_tools</a:documentation>
            <element name="dump_file_completeness">
              <a:documentation>Amount of information per dumpfile.
save the results to a file, the larger the value of
SAVRES the more results that are saved.
Manual suggests 100</a:documentation>
              <attribute name="replaces">
                <value>SAVRES</value>
              </attribute>
              <ref name="integer"/>
            </element>
            <ref name="comment"/>
          </element>
        </optional>
        <optional>
          <element name="checkpointing">
            <a:documentation>Whether to enable dumping of checkpointing output.

See http://amcg.ese.ic.ac.uk/index.php?title=Local:Checkpointing_from_new_options</a:documentation>
            <element name="checkpoint_period_in_dumps">
              <a:documentation>Checkpointing period, in dumps. Non-negative value required. A value of zero indicates that checkpoints should be created at every dump. If /io/max_dumpfile_count is exceeded then earlier checkpoints may be overwritten. </a:documentation>
              <ref name="integer"/>
            </element>
            <optional>
              <element name="checkpoint_at_start">
                <a:documentation>Enable to checkpoint at simulation start.</a:documentation>
                <ref name="comment"/>
              </element>
            </optional>
            <optional>
              <element name="checkpoint_at_end">
                <a:documentation>Enable to force a checkpoint at simulation end.</a:documentation>
                <ref name="comment"/>
              </element>
            </optional>
            <ref name="comment"/>
          </element>
        </optional>
        <optional>
          <element name="detectors">
            <a:documentation>Specification of detectors

At the moment only writes detector values to .s file
so you need to select the option /io/s_file as well.</a:documentation>
            <zeroOrMore>
              <element name="static_detector">
                <attribute name="name">
                  <data type="string"/>
                </attribute>
                <element name="location">
                  <ref name="real_dim_vector"/>
                </element>
              </element>
            </zeroOrMore>
          </element>
        </optional>
      </element>
      <element name="timestepping">
        <a:documentation>Options dealing with time discretisation</a:documentation>
        <element name="current_time">
          <a:documentation>Current simulation time. At the start of the simulation this
is the start time.</a:documentation>
          <attribute name="replaces">
            <value>ACCTIM</value>
          </attribute>
          <ref name="real"/>
        </element>
        <element name="finish_time">
          <a:documentation>Simulation time at which the simulation should end.</a:documentation>
          <attribute name="replaces">
            <value>LTIME</value>
          </attribute>
          <ref name="real"/>
        </element>
        <element name="timestep">
          <a:documentation>The time step size. If adaptive time stepping is used
then this is the initial time step size.</a:documentation>
          <attribute name="replaces">
            <value>DT</value>
          </attribute>
          <ref name="real"/>
        </element>
        <optional>
          <element name="cpu_time_limit">
            <a:documentation>Maximum CPU time (secs) taken up before
simulation terminates writing results to disc.
Manual suggests 1.E+20</a:documentation>
            <attribute name="replaces">
              <value>CPULIM</value>
            </attribute>
            <ref name="real"/>
          </element>
        </optional>
        <optional>
          <element name="wall_time_limit">
            <a:documentation>Maximum wall time (secs) taken up before
simulation terminates writing results to disc.
This is usually disabled.</a:documentation>
            <attribute name="replaces">
              <value>WATIME</value>
            </attribute>
            <ref name="real"/>
          </element>
        </optional>
        <optional>
          <element name="nonlinear_iterations">
            <a:documentation>maximum number of non-linear iterations.
Manual suggests 2</a:documentation>
            <attribute name="replaces">
              <value>ITINOI</value>
            </attribute>
            <ref name="integer"/>
            <optional>
              <element name="tolerance">
                <a:documentation>tolerance for non-linear iteration.
Manual suggests 1.0E-12</a:documentation>
                <attribute name="replaces">
                  <value>ITIERR</value>
                </attribute>
                <ref name="real"/>
              </element>
            </optional>
            <optional>
              <element name="terminate_if_not_converged">
                <a:documentation>Terminate the simulation if the number of nonlinear_iterations is reached
and the tolerance criterion is not met.
This is mostly useful as a debugging option if you suspect the solution is not converging.</a:documentation>
                <empty/>
              </element>
            </optional>
          </element>
        </optional>
        <optional>
          <element name="adaptive_timestep">
            <a:documentation>Vary the timestep to constrain the cfl number.</a:documentation>
            <attribute name="replaces">
              <value>TIMAUT</value>
            </attribute>
            <element name="maximum_cfl">
              <a:documentation>The timestep will be reduced to prevent the cfl exceeding this value.</a:documentation>
              <ref name="real"/>
            </element>
            <optional>
              <element name="minimum_timestep">
                <a:documentation>Minimum time step size if adaptive time stepping is been used.
Manual suggests 0.0</a:documentation>
                <attribute name="replaces">
                  <value>MINDT</value>
                </attribute>
                <ref name="real"/>
              </element>
            </optional>
            <optional>
              <element name="maximum_timestep">
                <a:documentation>Maximum time step size if adaptive time stepping is been used.
Manual suggests 1.E+10</a:documentation>
                <attribute name="replaces">
                  <value>MAXDT</value>
                </attribute>
                <ref name="real"/>
              </element>
            </optional>
            <optional>
              <element name="tolerance">
                <a:documentation>The maximum difference aimed at between two consecutive time steps.
For example, a tolerence of 1.1 allows a maximum difference
in the R2norm of 10 percent.
Manual suggests 1.02</a:documentation>
                <attribute name="replaces">
                  <value>AUTACC</value>
                </attribute>
                <ref name="real"/>
              </element>
            </optional>
            <optional>
              <element name="adaptive_timestep_repeat">
                <a:documentation>If AUTGOB * (accuracy suggested by AUTACC) is not reached then repeat time step.
=0 -- do not repeat time step
Manual suggests -2.0</a:documentation>
                <attribute name="replaces">
                  <value>AUTGOB</value>
                </attribute>
                <ref name="real"/>
              </element>
            </optional>
          </element>
        </optional>
        <optional>
          <!-- Preprocessor legacy: STEDER = 0. is equivalent to inactive. -->
          <element name="steady_state_tolerance">
            <a:documentation>Activate if you want to terminate the simulation once a steady state is reached.
Enter the tolerance to which you want a steady state to be judged.</a:documentation>
            <attribute name="replaces">
              <value>STEDER</value>
            </attribute>
            <ref name="real"/>
          </element>
        </optional>
      </element>
      <element name="physical_parameters">
        <a:documentation>The physical parameters</a:documentation>
        <optional>
          <element name="gravity">
            <a:documentation>Set a gravity to be included in the buoyancy term.</a:documentation>
            <element name="magnitude">
              <a:documentation>Acceleration due to gravity. 9.8 m/s^2 on earth.</a:documentation>
              <attribute name="replaces">
                <value>GRAVTY</value>
              </attribute>
              <ref name="real"/>
            </element>
            <element name="vector_field">
              <a:documentation>The direction of the gravity vector.</a:documentation>
              <attribute name="name">
                <value>GravityDirection</value>
              </attribute>
              <attribute name="rank">
                <value>1</value>
              </attribute>
              <attribute name="replaces">
                <value>BSOUX BSOUY BSOUZ</value>
              </attribute>
              <element name="prescribed">
                <ref name="prescribed_vector_field_no_adapt"/>
              </element>
            </element>
          </element>
        </optional>
        <optional>
          <element name="coriolis">
            <attribute name="replaces">
              <value>OPTOME</value>
            </attribute>
            <choice>
              <element name="f_plane">
                <a:documentation>f-plane approximation
f / 2 = f_0</a:documentation>
                <attribute name="replaces">
                  <value>OPTOME = 0</value>
                </attribute>
                <element name="f_0">
                  <a:documentation>f / 2 = f_0</a:documentation>
                  <attribute name="replaces">
                    <value>OMEGA</value>
                  </attribute>
                  <ref name="real"/>
                </element>
              </element>
              <element name="beta_plane">
                <a:documentation>Beta-plane approximation
f / 2 = f_0 + beta_vector . x</a:documentation>
                <attribute name="replaces">
                  <value>OPTOME = 1</value>
                </attribute>
                <element name="f_0">
                  <a:documentation>f_0, where:

f / 2 = f_0 + beta_vector . x</a:documentation>
                  <attribute name="replaces">
                    <value>OMEGA</value>
                  </attribute>
                  <ref name="real"/>
                </element>
                <element name="beta_vector">
                  <a:documentation>beta_vector, where:
f / 2 = f_0 + beta_vector . x
Note that this is not necessarily a unit vector (unlike GravityDirection).</a:documentation>
                  <attribute name="replaces">
                    <value>OMEGA1 OMEGA2 OMEGA3</value>
                  </attribute>
                  <ref name="real_dim_vector"/>
                </element>
              </element>
              <element name="sine_of_latitude">
                <a:documentation>Full Coriolis parameter:
f / 2 = omega sin (latitude)
Specify omega.</a:documentation>
                <attribute name="replaces">
                  <value>OPTOME = 2</value>
                </attribute>
                <element name="omega">
                  <attribute name="replaces">
                    <value>OMEGA</value>
                  </attribute>
                  <ref name="real"/>
                </element>
              </element>
              <element name="on_sphere">
                <a:documentation>Full representation on sphere</a:documentation>
                <element name="omega">
                  <a:documentation>Domain rotation vector</a:documentation>
                  <attribute name="replaces">
                    <value>OMEGA1 OMEGA2 OMEGA3</value>
                  </attribute>
                  <ref name="real_dim_vector"/>
                </element>
              </element>
            </choice>
          </element>
        </optional>
      </element>
      <oneOrMore>
        <element name="material_phase">
          <a:documentation>The material or phase options</a:documentation>
          <attribute name="name">
            <data type="string"/>
          </attribute>
          <optional>
            <element name="equation_of_state">
              <a:documentation>The equation of state</a:documentation>
              <choice>
                <element name="fluids">
                  <a:documentation>Equations of state for ocean (and simple fluid) applications</a:documentation>
                  <choice>
                    <element name="linear">
                      <a:documentation>Incompressible linear equation of state
(e.g. density=denini*(1.0-dengam*(temperature-temini)+dengam_sal*(salinity-S0)))</a:documentation>
                      <element name="reference_density">
                        <a:documentation>The reference or background density</a:documentation>
                        <attribute name="replaces">
                          <value>DENINI</value>
                        </attribute>
                        <ref name="real"/>
                      </element>
                      <optional>
                        <element name="temperature_dependency">
                          <a:documentation>Enable to add temperature dependency to the equation of state.</a:documentation>
                          <attribute name="replaces">
                            <value>BOUSIN</value>
                          </attribute>
                          <element name="reference_temperature">
                            <a:documentation>The reference or background temperature (actual temperature = calculated temperature plus this value).</a:documentation>
                            <attribute name="replaces">
                              <value>TEMINI</value>
                            </attribute>
                            <ref name="real"/>
                          </element>
                          <element name="thermal_expansion_coefficient">
                            <a:documentation>The thermal expansion coefficient</a:documentation>
                            <attribute name="replaces">
                              <value>DENGAM</value>
                            </attribute>
                            <ref name="real"/>
                          </element>
                        </element>
                      </optional>
                      <optional>
                        <element name="salinity_dependency">
                          <a:documentation>Enable to add salinity dependency to the equation of state.</a:documentation>
                          <attribute name="replaces">
                            <value>BOUSIN</value>
                          </attribute>
                          <element name="reference_salinity">
                            <a:documentation>The reference or background salinity (actual salinity = calculated salinity plus this value).</a:documentation>
                            <attribute name="replaces">
                              <value>S0 if from .dat file?, GAMDE3(1) if from gem</value>
                            </attribute>
                            <ref name="real"/>
                          </element>
                          <element name="saline_contraction_coefficient">
                            <a:documentation>The haline contraction coefficient - from .dat file currently?</a:documentation>
                            <attribute name="replaces">
                              <value>DENGAM_SAL if from .dat file?, GAMDE2(1) if from gem</value>
                            </attribute>
                            <ref name="real"/>
                          </element>
                        </element>
                      </optional>
                      <optional>
                        <element name="subtract_out_hydrostatic_level">
                          <a:documentation>Enable this option to subtract out the hydrostatic level</a:documentation>
                          <attribute name="replaces">
                            <value>BHOUT</value>
                          </attribute>
                          <empty/>
                        </element>
                      </optional>
                      <optional>
                        <element name="bousinesq_change_density">
                          <a:documentation>Changes the density for the Boussinesq approx.
Manual suggests false</a:documentation>
                          <attribute name="replaces">
                            <value>CHADEN</value>
                          </attribute>
                          <empty/>
                        </element>
                      </optional>
                    </element>
                    <element name="ocean_pade_approximation">
                      <a:documentation>2002 McDougall, Jackett, Wright and Feistel equation of state using Pade approximation</a:documentation>
                      <empty/>
                    </element>
                  </choice>
                </element>
                <element name="multimaterial">
                  <a:documentation>Equations of state for multi-material (solid/fluid) applications</a:documentation>
                  <element name="miegrunneisen">
                    <a:documentation>Mie-Grunneisen EoS
Used with multimaterial compressible simulations</a:documentation>
                    <attribute name="replace">
                      <value>MKCOMP from solidity_inputs.inp</value>
                    </attribute>
                    <optional>
                      <element name="reference_density">
                        <a:documentation>reference uncompressed density
if activated then either Liquid EoS or full Mie-Grunneisen EoS
- replaces EOS TYPE = 1 or 3 from solidity_imputs.inp -&gt; MATEOS
if not activated then replaces EOS TYPE 2 from
solidity_inputs.inp -&gt; MATEOS</a:documentation>
                        <attribute name="replaces">
                          <value>DENINI for single materials, REFERENCE DENS. from solidity_inputs.inp -&gt; DENINIMAT for multimaterials</value>
                        </attribute>
                        <ref name="real"/>
                      </element>
                    </optional>
                    <optional>
                      <element name="ratio_specific_heats">
                        <a:documentation>Ratio of specific heats at constant pressure to that at constant volume
Requires an energy field
if activated then a full Mie-Grunneisen EoS - replaces EOS TYPE = 3
from solidity_imputs.inp -&gt; MATEOS
if not activated then either EOS TYPE 1 or 3
from solidity_inputs.inp -&gt; MATEOS</a:documentation>
                        <attribute name="replaces">
                          <value>DENGAM for single materials, DEN GAM from solidity_inputs.inp -&gt; DENGAMMAT for multimaterials</value>
                        </attribute>
                        <ref name="real"/>
                      </element>
                    </optional>
                    <optional>
                      <element name="bulk_sound_speed_squared">
                        <a:documentation>bulk_sound_speed_squared = isothermal_bulk_modulus/reference_density
if activated then either full or partial Liquid EoS or full
Mie-Grunneisen EoS - replaces EOS TYPE = 1, 2 or 3
from solidity_imputs.inp -&gt; MATEOS</a:documentation>
                        <attribute name="replaces">
                          <value>GASCON for single materials, COMPRESS COEF. from solidity_inputs.inp -&gt; GASCONMAT for multimaterials</value>
                        </attribute>
                        <ref name="real"/>
                      </element>
                    </optional>
                  </element>
                </element>
                <element name="multiphase">
                  <a:documentation>Equations of state for multiphase applications</a:documentation>
                  <choice>
                    <element name="liquid">
                      <a:documentation>A liquid equation of state for multiphase simulations</a:documentation>
                      <attribute name="replaces">
                        <value>EQNSTA = 1, COMPRE = TRUE</value>
                      </attribute>
                      <element name="legacy_gas_constant">
                        <a:documentation>Real gas constant for gas eos or speed of sound squared for liquid eos.
Manual suggests 0.0</a:documentation>
                        <attribute name="replaces">
                          <value>GASCON</value>
                        </attribute>
                        <ref name="real"/>
                      </element>
                      <element name="reference_density">
                        <a:documentation>Equations of state: used for compressible multiphase  flows
The reference or initial density</a:documentation>
                        <attribute name="replaces">
                          <value>DENINI</value>
                        </attribute>
                        <ref name="real"/>
                      </element>
                      <element name="thermal_expansion_coefficient">
                        <a:documentation>The thermal expansion coefficient</a:documentation>
                        <attribute name="replaces">
                          <value>DENGAM</value>
                        </attribute>
                        <ref name="real"/>
                      </element>
                      <element name="reference_temperature">
                        <a:documentation>The reference or background temperature</a:documentation>
                        <attribute name="replaces">
                          <value>TEMINI</value>
                        </attribute>
                        <ref name="real"/>
                      </element>
                      <element name="legacy_gamde2">
                        <a:documentation>Multiphase compressibility parameter (TBD)
Manual suggests 0.0</a:documentation>
                        <attribute name="replaces">
                          <value>GAMDE2</value>
                        </attribute>
                        <ref name="real"/>
                      </element>
                      <element name="legacy_gamde3">
                        <a:documentation>Multiphase compressibility parameter (TBD)
Manual suggests 0.0</a:documentation>
                        <attribute name="replaces">
                          <value>GAMDE3</value>
                        </attribute>
                        <ref name="real"/>
                      </element>
                    </element>
                    <element name="ideal_gas">
                      <a:documentation>An ideal gas equation of state for multiphase simulations</a:documentation>
                      <attribute name="replaces">
                        <value>EQNSTA = 2, COMPRE = TRUE</value>
                      </attribute>
                      <element name="legacy_gas_constant">
                        <a:documentation>Multiphase or 1-material compressibility.
Real gas constant for gas eos or speed of sound squared for liquid eos.
Manual suggests 0.0</a:documentation>
                        <attribute name="replaces">
                          <value>GASCON</value>
                        </attribute>
                        <ref name="real"/>
                      </element>
                    </element>
                    <element name="incompressible">
                      <a:documentation>an incompressible equation of state for multiphase simulations</a:documentation>
                      <attribute name="replaces">
                        <value>EQNSTA = 3, COMPRE = TRUE</value>
                      </attribute>
                      <element name="reference_density">
                        <a:documentation>Equations of state: used for compressible multiphase  flows
The reference or initial density</a:documentation>
                        <attribute name="replaces">
                          <value>DENINI</value>
                        </attribute>
                        <ref name="real"/>
                      </element>
                    </element>
                    <element name="water_steam">
                      <a:documentation>equation of state for water-steam</a:documentation>
                      <attribute name="replaces">
                        <value>EQNSTA = 4, COMPRE = TRUE</value>
                      </attribute>
                    </element>
                    <element name="silica">
                      <a:documentation>equation of state for silica</a:documentation>
                      <attribute name="replaces">
                        <value>EQNSTA = 6, COMPRE = TRUE</value>
                      </attribute>
                    </element>
                    <element name="lime_neu">
                      <a:documentation>equation of state for lime</a:documentation>
                      <attribute name="replaces">
                        <value>EQNSTA = 7, COMPRE = TRUE</value>
                      </attribute>
                    </element>
                    <element name="silica_neu">
                      <a:documentation>equation of state for silica</a:documentation>
                      <attribute name="replaces">
                        <value>EQNSTA = 8, COMPRE = TRUE</value>
                      </attribute>
                    </element>
                    <element name="granite_neu">
                      <a:documentation>equation of state for granite</a:documentation>
                      <attribute name="replaces">
                        <value>EQNSTA = 9, COMPRE = TRUE</value>
                      </attribute>
                    </element>
                    <element name="znst">
                      <a:documentation>equation of state for ZnSt</a:documentation>
                      <attribute name="replaces">
                        <value>EQNSTA = 10, COMPRE = TRUE</value>
                      </attribute>
                    </element>
                    <element name="uo2">
                      <a:documentation>equation of state for UO2</a:documentation>
                      <attribute name="replaces">
                        <value>EQNSTA = 11, COMPRE = TRUE</value>
                      </attribute>
                    </element>
                    <element name="simplified_znst">
                      <a:documentation>simplified zinc stearate EOS</a:documentation>
                      <attribute name="replaces">
                        <value>13 &lt;= EQNSTA &lt;= 23, COMPRE = TRUE</value>
                      </attribute>
                      <ref name="integer"/>
                    </element>
                    <element name="simplified_uo2">
                      <a:documentation>simplified uranium dioxide EOS</a:documentation>
                      <attribute name="replaces">
                        <value>24 &lt;= EQNSTA &lt;= 33, COMPRE = TRUE</value>
                      </attribute>
                      <ref name="integer"/>
                    </element>
                    <element name="multicomponent">
                      <a:documentation>Option for which set of EOS's would it be applied.  For multicomponents and
multiphase flows. It is associated to a dummy field which blends and normalise
them according to the volume fraction (alpha_i * rho_i)</a:documentation>
                      <element name="reference_density">
                        <a:documentation>Equations of state: used for compressible multiphase multicomponent flows
The reference or initial density</a:documentation>
                        <attribute name="replaces">
                          <value>MIXCO2</value>
                        </attribute>
                        <ref name="real"/>
                      </element>
                      <element name="reference_temperature">
                        <a:documentation>The reference or initial temperature</a:documentation>
                        <attribute name="replaces">
                          <value>MIXCO4</value>
                        </attribute>
                        <ref name="real"/>
                      </element>
                      <element name="thermal_expansion_coefficient">
                        <a:documentation>The thermal expansion coefficient</a:documentation>
                        <attribute name="replaces">
                          <value>MIXCO3</value>
                        </attribute>
                        <ref name="real"/>
                      </element>
                      <element name="speed_of_sound">
                        <a:documentation>The speed of sound (= 1/c2 = (drho/dp)^2)</a:documentation>
                        <attribute name="replaces">
                          <value>MIXCO1</value>
                        </attribute>
                        <ref name="real"/>
                      </element>
                      <choice>
                        <element name="mix_znst">
                          <attribute name="replaces">
                            <value>MIXEOS = 10</value>
                          </attribute>
                        </element>
                        <element name="mix_uo2">
                          <attribute name="replaces">
                            <value>MIXEOS = 11</value>
                          </attribute>
                        </element>
                        <element name="simplified_mix_znst">
                          <attribute name="replaces">
                            <value>13 &lt;= MIXEOS &lt;= 23</value>
                          </attribute>
                          <ref name="integer"/>
                        </element>
                        <element name="simplified_mix_uo2">
                          <attribute name="replaces">
                            <value>24 &lt;= MIXEOS &lt;= 33</value>
                          </attribute>
                          <ref name="integer"/>
                        </element>
                      </choice>
                      <choice>
                        <element name="latent_heat_water">
                          <a:documentation>latent heat option - water</a:documentation>
                          <attribute name="replaces">
                            <value>MIXOLA = 1</value>
                          </attribute>
                        </element>
                        <element name="latent_heat_znst">
                          <a:documentation>latent heat option - ZnSt</a:documentation>
                          <choice>
                            <element name="melting_temperature_variable">
                              <a:documentation>melting/vaporisation temperature varying with pressure</a:documentation>
                              <attribute name="replaces">
                                <value>MIXOLA = 2</value>
                              </attribute>
                            </element>
                            <element name="melting_temperature_constant">
                              <a:documentation>constant melting/vaporisation temperature</a:documentation>
                              <attribute name="replaces">
                                <value>MIXOLA = 3</value>
                              </attribute>
                            </element>
                          </choice>
                        </element>
                        <element name="latent_heat_mox_uo2">
                          <a:documentation>latent heat option - MOX/UO2</a:documentation>
                          <choice>
                            <element name="melting_temperature_variable">
                              <a:documentation>melting/vaporisation temperature varying with pressure</a:documentation>
                              <attribute name="replaces">
                                <value>MIXOLA = 4</value>
                              </attribute>
                            </element>
                            <element name="melting_temperature_constant">
                              <a:documentation>constant melting/vaporisation temperature</a:documentation>
                              <attribute name="replaces">
                                <value>MIXOLA = 5</value>
                              </attribute>
                            </element>
                          </choice>
                        </element>
                      </choice>
                      <element name="heat_capacity">
                        <choice>
                          <element name="legacy_mixocp_21">
                            <attribute name="replaces">
                              <value>MIXOCP = 21</value>
                            </attribute>
                            <empty/>
                          </element>
                          <element name="legacy_mixocp_22">
                            <attribute name="replaces">
                              <value>MIXOCP = 22</value>
                            </attribute>
                            <empty/>
                          </element>
                          <element name="legacy_mixocp_23">
                            <attribute name="replaces">
                              <value>MIXOCP = 23</value>
                            </attribute>
                            <empty/>
                          </element>
                          <element name="legacy_mixocp_10_20">
                            <attribute name="replaces">
                              <value>10 &lt; MIXOCP &lt;= 20</value>
                            </attribute>
                            <empty/>
                          </element>
                          <element name="legacy_mixocp_4">
                            <attribute name="replaces">
                              <value>MIXOCP = 4</value>
                            </attribute>
                            <empty/>
                          </element>
                        </choice>
                        <element name="value">
                          <attribute name="replaces">
                            <value>HEACAP, TCV</value>
                          </attribute>
                          <ref name="real"/>
                        </element>
                      </element>
                    </element>
                  </choice>
                  <element name="heat_transfer">
                    <a:documentation>Set of options for heat transfer.
Replaces IDEHCO = XaaYZbbbb. Digits 'a' and 'b' were not used.
X and YZ are conductivity and interphase options, respectively.
Associated with the phases</a:documentation>
                    <choice>
                      <element name="zeher_conductivity">
                        <attribute name="replaces">
                          <value>IDEHCO = 1aaYZbbbb</value>
                        </attribute>
                      </element>
                      <element name="natarajan_hunt_conductivity">
                        <attribute name="replaces">
                          <value>IDEHCO = 2aaYZbbbb</value>
                        </attribute>
                      </element>
                      <element name="hunt_conductivity">
                        <attribute name="replaces">
                          <value>IDEHCO = 3aaYZbbbb</value>
                        </attribute>
                      </element>
                      <element name="lun_conductivity">
                        <attribute name="replaces">
                          <value>IDEHCO = 4aaYZbbbb</value>
                        </attribute>
                      </element>
                      <element name="syamlal_conductivity">
                        <attribute name="replaces">
                          <value>IDEHCO = 5aaYZbbbb</value>
                        </attribute>
                      </element>
                      <element name="gidaspow_conductivity">
                        <attribute name="replaces">
                          <value>IDEHCO = 6aaYZbbbb</value>
                        </attribute>
                      </element>
                    </choice>
                    <choice>
                      <element name="gunn_interphase">
                        <attribute name="replaces">
                          <value>IDEHCO = Xaa20bbbb</value>
                        </attribute>
                      </element>
                      <element name="alt_gunn_interphase">
                        <attribute name="replaces">
                          <value>IDEHCO = Xaa30bbbb</value>
                        </attribute>
                      </element>
                    </choice>
                  </element>
                </element>
              </choice>
            </element>
          </optional>
          <optional>
            <element name="subgridscale_parameterisations">
              <a:documentation>Subgridscale parameterisations</a:documentation>
              <optional>
                <element name="LANS">
                  <a:documentation>Lagrangian-averaged Navier-Stokes equations </a:documentation>
                  <choice>
                    <element name="alpha_isotropic_homogeneous">
                      <a:documentation>smoothing length specified as isotropic homogeneous</a:documentation>
                      <ref name="real"/>
                    </element>
                    <element name="alpha_anisotropic_homogeneous_cartesian">
                      <ref name="real_dim_symmetric_tensor"/>
                    </element>
                  </choice>
                  <!--
                                  (
                                     element leray {
                                        empty
                                     }|
                                     element LANS_momentum_form {
                                        empty
                                     }|
                                     element LANS_stress_form {
                                        empty
                                     }
                                  )
                  -->
                </element>
              </optional>
              <optional>
                <element name="Gent_McWilliams">
                  <a:documentation>You MUST add the following additional fields for this:
DistanceToTop
DistanceToBottom
DistanceToSideBoundaries
PerturbationDensity</a:documentation>
                  <element name="isoneutral_diffusivity">
                    <a:documentation>This is the diffusivity along density surfaces. At the moment the dianeutral diffusivity is hardcoded to be 10^-7 x isoneutral_diffusivity.</a:documentation>
                    <ref name="real"/>
                  </element>
                  <element name="GentMcWilliams_diffusivity">
                    <a:documentation>This is the diffusivity that parameterises the effects of the baroclinic eddies.</a:documentation>
                    <ref name="real"/>
                  </element>
                  <element name="tapering">
                    <a:documentation>The vertical and off-diagonal components of the Gent-McWilliams diffusivity tensor need to be tapered to zero near the boundaries of the domain. A taper should also be applied where the density slope is large - define "large" by setting maximum_density_slope below.</a:documentation>
                    <element name="maximum_density_slope">
                      <a:documentation>Where the slope of the density surface is greater than or equal to the maximum_density_slope, an exponential taper is applied to the isoneutral diffusivity and a linear taper is applied to the GentMcWilliams diffusivity.</a:documentation>
                      <ref name="real"/>
                    </element>
                    <element name="width_of_exponential_taper_region">
                      <a:documentation>The exponential taper has the form tanh((S_max-sqrt(S.S))/S_d) where S_mac is the maximum_density_slope, S is the local slope of the density surface and S_d is a parameter that controls the width of the tapering region.</a:documentation>
                      <ref name="real"/>
                    </element>
                    <element name="first_baroclinic_Rossby_radius">
                      <a:documentation>If the slope of the density surface is less than the maximum_density_slope but we are still near the surface, a sine taper is applies to both the diffusivities - "near" is defined as d &lt; R1 |S| where d is the distance to the top, |S| is the slope of the density surface and R1 is the first_baroclinic_Rossby_radius.</a:documentation>
                      <ref name="real"/>
                    </element>
                    <element name="constant_for_linear_taper">
                      <a:documentation>Near the bottom and side boundaries the Gent-McWlliams diffusivity is tapered to zero by multiplying by c*DistanceToBoundary</a:documentation>
                      <ref name="real"/>
                    </element>
                  </element>
                </element>
              </optional>
              <optional>
                <element name="Mellor_Yamada">
                  <a:documentation>You MUST set the following fields for this:
KineticEnergy
TurbulentLengthScalexKineticEnergy
For visualisation purposes, you can also set
VerticalViscosity
VerticalDiffusivity</a:documentation>
                  <empty/>
                </element>
              </optional>
            </element>
          </optional>
          <optional>
            <element name="scalar_field">
              <a:documentation>Pressure</a:documentation>
              <attribute name="rank">
                <value>0</value>
              </attribute>
              <attribute name="name">
                <value>Pressure</value>
              </attribute>
              <choice>
                <a:documentation>Field type</a:documentation>
                <element name="prognostic">
                  <!-- in the future this can be any mesh_choice: -->
                  <element name="mesh">
                    <attribute name="name">
                      <value>PressureMesh</value>
                    </attribute>
                  </element>
                  <ref name="prognostic_pressure_field"/>
                </element>
                <element name="prescribed">
                  <!-- in the future this can be any mesh_choice: -->
                  <element name="mesh">
                    <attribute name="name">
                      <value>PressureMesh</value>
                    </attribute>
                  </element>
                  <ref name="prescribed_scalar_field"/>
                </element>
                <element name="aliased">
                  <attribute name="material_phase_name">
                    <data type="string"/>
                  </attribute>
                  <attribute name="field_name">
                    <value>Pressure</value>
                  </attribute>
                </element>
              </choice>
            </element>
          </optional>
          <optional>
            <element name="scalar_field">
              <a:documentation>Density</a:documentation>
              <attribute name="rank">
                <value>0</value>
              </attribute>
              <attribute name="name">
                <value>Density</value>
              </attribute>
              <choice>
                <a:documentation>Field type</a:documentation>
                <element name="diagnostic">
                  <ref name="velocity_mesh_choice"/>
                  <ref name="diagnostic_scalar_field"/>
                </element>
                <element name="prescribed">
                  <ref name="velocity_mesh_choice"/>
                  <ref name="prescribed_scalar_field"/>
                </element>
                <element name="aliased">
                  <attribute name="material_phase_name">
                    <data type="string"/>
                  </attribute>
                  <attribute name="field_name">
                    <value>Density</value>
                  </attribute>
                </element>
              </choice>
            </element>
          </optional>
          <optional>
            <element name="vector_field">
              <a:documentation>Velocity vector and momentum options</a:documentation>
              <attribute name="rank">
                <value>1</value>
              </attribute>
              <attribute name="name">
                <value>Velocity</value>
              </attribute>
              <choice>
                <a:documentation>Field type</a:documentation>
                <element name="prognostic">
                  <ref name="velocity_mesh_choice"/>
                  <ref name="prognostic_velocity_field"/>
                </element>
                <element name="prescribed">
                  <ref name="velocity_mesh_choice"/>
                  <ref name="prescribed_vector_field"/>
                </element>
                <element name="aliased">
                  <attribute name="material_phase_name">
                    <data type="string"/>
                  </attribute>
                  <attribute name="field_name">
                    <value>Velocity</value>
                  </attribute>
                </element>
              </choice>
            </element>
          </optional>
          <zeroOrMore>
            <ref name="scalar_field_choice"/>
          </zeroOrMore>
          <zeroOrMore>
            <ref name="vector_field_choice"/>
          </zeroOrMore>
          <zeroOrMore>
            <ref name="tensor_field_choice"/>
          </zeroOrMore>
        </element>
      </oneOrMore>
      <optional>
        <element name="mesh_adaptivity">
          <a:documentation>Mesh adaptivity options</a:documentation>
          <optional>
            <element name="mesh_movement">
              <a:documentation>Options involving mesh movement (Lagrangian, ALE methods)
Allow a moving mesh.
Assigns memory for grid velocities
Amends previous timestep's mass matrix
If solid, enables lagrangian movement
Manual suggests off.</a:documentation>
              <attribute name="replaces">
                <value>MVMESH = TRUE, ZERQG, CMCHAN = TRUE</value>
              </attribute>
              <optional>
                <choice>
                  <element name="lagrangian">
                    <a:documentation>enable pure lagrangian movement of mesh</a:documentation>
                    <attribute name="replaces">
                      <value>SOLIDS &gt; 0 from solidity_options.inp</value>
                    </attribute>
                    <empty/>
                  </element>
                  <element name="full_ale">
                    <a:documentation>enable full ale movement of mesh</a:documentation>
                    <attribute name="replaces">
                      <value>NCOLOP = XXXXX1X</value>
                    </attribute>
                    <empty/>
                  </element>
                  <element name="vertical_ale">
                    <a:documentation>enable vertical movement of mesh (TBD)</a:documentation>
                    <choice>
                      <element name="minimise_relative_velocity_dot_grad_density">
                        <a:documentation>Don't know for sure that this is in an approripate place</a:documentation>
                        <attribute name="replaces">
                          <value>NCOLOP = -1</value>
                        </attribute>
                        <empty/>
                      </element>
                      <element name="use_hessian_density">
                        <a:documentation>Don't know for sure that this is in an approripate place</a:documentation>
                        <attribute name="replaces">
                          <value>NCOLOP = -2</value>
                        </attribute>
                        <empty/>
                      </element>
                    </choice>
                  </element>
                </choice>
              </optional>
            </element>
          </optional>
          <optional>
            <element name="hr_adaptivity">
              <a:documentation>Anisotropic mesh hr-adaptivity</a:documentation>
              <attribute name="replaces">
                <value>ADMESH</value>
              </attribute>
              <choice>
                <element name="period">
                  <a:documentation>Time interval (in simulation time) when mesh adaptivity performed.
Usually set to 10-20 times the timestep.</a:documentation>
                  <attribute name="replaces">
                    <value>TIMMES</value>
                  </attribute>
                  <ref name="real"/>
                </element>
                <element name="period_in_timesteps">
                  <a:documentation>Adapt period in timesteps.</a:documentation>
                  <ref name="integer"/>
                </element>
              </choice>
              <optional>
                <element name="cpu_period">
                  <a:documentation>Time interval (in cpu time) when mesh adaptivity performed
Manual suggests disabling this option.</a:documentation>
                  <attribute name="replaces">
                    <value>CPUMES</value>
                  </attribute>
                  <ref name="real"/>
                </element>
              </optional>
              <element name="maximum_number_of_nodes">
                <a:documentation>The maximum number of nodes this simulation may use.
In parallel, this is the maximum number of nodes per process.
If the mesh adaptivity algorithm wants to place more
nodes than this, the desired mesh is coarsened
everywhere in space until it will fit within this limit.
In general, the error tolerances should be set so that
this is never reached; it should only be a safety catch.
A typical value is 100000.</a:documentation>
                <attribute name="replaces">
                  <value>MXNODS</value>
                </attribute>
                <ref name="integer"/>
              </element>
              <optional>
                <element name="functional_tolerance">
                  <a:documentation>Functional value above which elements are considered for adaption.
0.5 to 1.0 seems O.K- it can be negative.
0.5 corresponds to a minimum insphere radius 0f 0.3 relative 1 and max-edge size 2.
Value used in code is MAX(ABS(MESTP1), 0.15)
Manual suggests 0.0</a:documentation>
                  <attribute name="replaces">
                    <value>MESTP1</value>
                  </attribute>
                  <ref name="real"/>
                </element>
              </optional>
              <optional>
                <element name="maximum_aspect_ratio">
                  <a:documentation>Maximum aspect ratio allowed between metric tensor eigenvalues.
A value of 0 indicates that there is no limit.
If left as zero then updated with MESTP3=10000000.0
Manual suggests disabling this option</a:documentation>
                  <attribute name="replaces">
                    <value>MESTP2</value>
                  </attribute>
                  <ref name="real"/>
                </element>
              </optional>
              <choice>
                <element name="enable_gradation">
                  <a:documentation>Gradation constrains the jump
in desired edge lengths along an edge, i.e.
it controls how fast the mesh size may change.</a:documentation>
                  <optional>
                    <element name="gradation_parameter">
                      <a:documentation>The gradation parameter. Must be a real &gt;= 1.0.
The gradation parameter constrains the jump
in desired edge lengths along an edge, i.e.
it controls how fast the mesh size may change.
A constant of 1.0 enforces a mesh of constant
edge length everywhere. A value of 2.0 would
allow the element size to double from element
to element. The default value is 1.5.</a:documentation>
                      <ref name="real"/>
                    </element>
                  </optional>
                </element>
                <element name="disable_gradation">
                  <a:documentation>Gradation constrains the jump
in desired edge lengths along an edge, i.e.
it controls how fast the mesh size may change.</a:documentation>
                  <empty/>
                </element>
              </choice>
              <optional>
                <element name="geometric_constaints">
                  <a:documentation>Apply geometric constraints to the metric formation.

As specified in (Pain, 2001), the mesh adaptivity
scheme attempts to formulate an appropriate edge length
for each direction at each point in space, independent
of problem, PDE or domain.

This option instructs the error metric formation
code to inspect the boundaries of the domain
and to bound the edge lengths requested appropriately.
This procedure stops the metric from asking for edge lengths
that are inappropriately large in comparison to the
resolution required to preserve the geometric accuracy
of the boundaries.

If you get 'knife hands' near domain boundaries,
turn this on.</a:documentation>
                  <empty/>
                </element>
              </optional>
              <optional>
                <element name="bounding_box_factor">
                  <a:documentation>Bounding box factor.

If the length scales specified by the metric are
unrealistically large, the mesh optimisation
algorithm can get confused. An example
would be specifying a length scale in a direction to be an
order of magnitude greater than the width
of the domain.

In order to fix this, the edge lengths requested
are bounded by the bounding box of the domain
(the smallest cuboid that contains the domain).
However, it was found that bounding by the bounding
box impairs the generation of anisotropic elements
in the mesh optimisation algorithm.

This option is multiplied by the bounding box of the domain
before it bounds the metric formed from other
considerations. By default, it is set to 2.0.</a:documentation>
                  <ref name="real"/>
                </element>
              </optional>
              <optional>
                <element name="goal_based_adaptivity">
                  <a:documentation>Goal-based adaptivity. With this option,
rather than taking the user-specified interpolation
error bounds as the weights to form the error metric
from the Hessians of the solution fields,
the interpolation weight is computed to optimally
represent the value of some specified functional
of state. In other words, the mesh is optimised
for the representation of a particular goal.

This is currently experimental. Activating
this option induces the code to ignore
any error bounds associated with the fields
specified under a material_phase.

For more information on this scheme,
see (Venditti &amp; Darmofal, 2003), or
(Power et. al, 2006).

Coding your own goal is also possible
but currently undocumented. See
error_measures/Goals.F90
for examples.</a:documentation>
                  <choice>
                    <element name="enstrophy_goal">
                      <a:documentation>Optimise for the representation of
enstrophy,
0.5 * int( |curl(velocity)|**2 ) dV.</a:documentation>
                      <attribute name="subroutine">
                        <value>goal_enstrophy</value>
                      </attribute>
                      <attribute name="dependencies">
                        <value>Velocity%1 Velocity%2 Velocity%3</value>
                      </attribute>
                    </element>
                    <element name="temperature_gradient_goal">
                      <a:documentation>Optimise for the representation of
gradients of temperature,
int(|grad(temperature)|**2) dV.</a:documentation>
                      <attribute name="subroutine">
                        <value>goal_temp</value>
                      </attribute>
                      <attribute name="dependencies">
                        <value>Temperature</value>
                      </attribute>
                    </element>
                    <element name="les_goal">
                      <a:documentation>Optimise for the contribution of the standard
Smagorinsky LES tensor.

In effect, this goal minimises
the contribution of the sub-filter scale
model -- it applies mesh resolution where
the sub-grid scale model has an effect.

int( transpose(grad(u)) . kappa . grad(u) ) dV,
with u ranging over the components of (nonlinear)
velocity and kappa the LES tensor.</a:documentation>
                      <attribute name="subroutine">
                        <value>goal_les_velocity</value>
                      </attribute>
                      <attribute name="dependencies">
                        <value>NonlinearVelocity%1 NonlinearVelocity%2 NonlinearVelocity%3</value>
                      </attribute>
                      <optional>
                        <element name="nonlinear_iterations">
                          <a:documentation>The number of nonlinear iterations to perform when
forming the metric with this goal.

Because the LES tensor explicitly depends on mesh sizing,
we can form a metric and feed this back into the goal,
using the proposed mesh sizing instead of the current mesh.
This allows us to simulate adapts without actually incurring
the cost of adaptation, for the purposes of converging the metric.
The default value is 3.</a:documentation>
                          <ref name="integer"/>
                        </element>
                      </optional>
                    </element>
                    <element name="higher_order_les_goal">
                      <a:documentation>Optimise for the contribution of the new 4th-order
LES tensor.

In effect, this goal minimises
the contribution of the sub-filter scale
model -- it applies mesh resolution where
the sub-grid scale model has an effect.

int( transpose(grad(u))   . kappa . grad(u) ) dV -
int( transpose(grad_h(u)) . kappa . grad_h(u) ) dV
with u ranging over the components of (nonlinear)
velocity, kappa the LES tensor,
grad(.) differentiation of basis functions and
grad_h(.) the Galerkin projection of the first derivative.</a:documentation>
                      <attribute name="subroutine">
                        <value>goal_les_velocity_4th</value>
                      </attribute>
                      <attribute name="dependencies">
                        <value>NonlinearVelocity%1 NonlinearVelocity%2 NonlinearVelocity%3</value>
                      </attribute>
                      <optional>
                        <element name="nonlinear_iterations">
                          <a:documentation>The number of nonlinear iterations to perform when
forming the metric with this goal.

Because the LES tensor explicitly depends on mesh sizing,
we can form a metric and feed this back into the goal,
using the proposed mesh sizing instead of the current mesh.
This allows us to simulate adapts without actually incurring
the cost of adaptation, for the purposes of converging the metric.
The default value is 3.</a:documentation>
                          <ref name="integer"/>
                        </element>
                      </optional>
                    </element>
                  </choice>
                  <choice>
                    <element name="relative_tolerance">
                      <a:documentation>The tolerance of the goal specifies the acceptable
error in the quantity computed. The adaptation scheme
attempts to adapt the mesh to ensure that the
goal computed from the primitive solution is 
within the tolerance specified here.

A relative tolerance specifies that the acceptable error
in the goal is some fraction of the value as computed
from the primitive solution. It is generally 
the easiest to use. This is a unitless percentage.</a:documentation>
                      <ref name="real"/>
                    </element>
                    <element name="absolute_tolerance">
                      <a:documentation>The tolerance of the goal specifies the acceptable
error in the quantity computed. The adaptation scheme
attempts to adapt the mesh to ensure that the
goal computed from the primitive solution is 
within the tolerance specified here.

An absolute tolerance specifies the acceptable error
in the goal, in the units of the goal itself.</a:documentation>
                      <ref name="real"/>
                    </element>
                  </choice>
                </element>
              </optional>
              <choice>
                <element name="constant_size_constraint">
                  <a:documentation>The mesh size constraint. This choice specifies
a mesh size constraint that is both spatially
and directionally homogenous.

OPHSAM = 0 -- Constant size constraint
OPHSAM = 1 -- Variable size constraint</a:documentation>
                  <attribute name="replaces">
                    <value>OPHSAM = 0</value>
                  </attribute>
                  <element name="minimum_edge_length">
                    <a:documentation>The minimum edge length of the mesh.
This should only be used as a safety net to ensure
sanity of the resulting mesh; ideally you should set your adaptivity
weights appropriately so that this is never used.</a:documentation>
                    <attribute name="replaces">
                      <value>MINCH</value>
                    </attribute>
                    <ref name="real"/>
                  </element>
                  <element name="maximum_edge_length">
                    <a:documentation>The maximum edge length of the mesh.
This should only be used as a safety net to ensure
sanity of the resulting mesh; ideally you should set your adaptivity
weights appropriately so that this is never used.</a:documentation>
                    <attribute name="replaces">
                      <value>MAXCH</value>
                    </attribute>
                    <ref name="real"/>
                  </element>
                </element>
                <element name="variable_size_constraint">
                  <a:documentation>The mesh size constraint. This choice specifies
a mesh size constraint that can vary both spatially
and directionally. To vary it directionally,
specify a symmetric metric tensor for the maximum
and minimum edge lengths; to vary it spatially,
add more size_tensors and place them appropriately:
the mesh size constraint at a given point will be
the interpolant of the size_tensors you have specified.

OPHSAM = 0 -- Constant size constraint
OPHSAM = 1 -- Variable size constraint</a:documentation>
                  <attribute name="replaces">
                    <value>OPHSAM = 1</value>
                  </attribute>
                  <oneOrMore>
                    <element name="size_tensor">
                      <a:documentation>The minimum and maximum edge lengths are symmetric tensors;
the position specifies where it is in the domain.</a:documentation>
                      <attribute name="replaces">
                        <value>NHSAMP</value>
                      </attribute>
                      <element name="minimum_edge_length">
                        <a:documentation>The minimum edge length, expressed as a symmetric tensor.</a:documentation>
                        <attribute name="replaces">
                          <value>HMINXX HMINXY HMINXZ HMINYY HMINYZ HMINZZ</value>
                        </attribute>
                        <ref name="real_dim_symmetric_tensor"/>
                      </element>
                      <element name="maximum_edge_length">
                        <a:documentation>The maximum edge length, expressed as a symmetric tensor.</a:documentation>
                        <attribute name="replaces">
                          <value>HMAXXX HMAXXY HMAXXZ HMAXYY HMAXYZ HMAXZZ</value>
                        </attribute>
                        <ref name="real_dim_symmetric_tensor"/>
                      </element>
                      <element name="position">
                        <a:documentation>The position of these tensors in the domain.</a:documentation>
                        <attribute name="replaces">
                          <value>XHSAMP YHSAMP ZHSAMP</value>
                        </attribute>
                        <ref name="real_dim_vector"/>
                      </element>
                    </element>
                  </oneOrMore>
                </element>
              </choice>
              <optional>
                <element name="element_length_limits">
                  <a:documentation>lower &amp; upper limits for derefinment and refinment
respectively - we do not change mesh unless our mesh is outside
these limits. These are the lower and upper limits of element
lengths in the undistorted system where =1 is ideal.</a:documentation>
                  <attribute name="replaces">
                    <value>CRIUP</value>
                  </attribute>
                  <element name="lower">
                    <attribute name="replaces">
                      <value>CRILOW = MOD(CRIUP,100.)</value>
                    </attribute>
                    <ref name="real"/>
                  </element>
                  <element name="upper">
                    <attribute name="replaces">
                      <value>(CRIUP-CRILOW)/100.</value>
                    </attribute>
                    <ref name="real"/>
                  </element>
                </element>
              </optional>
              <optional>
                <element name="adapt_at_first_timestep">
                  <attribute name="replaces">
                    <value>NCOLOP = XXXX1XX</value>
                  </attribute>
                  <empty/>
                  <optional>
                    <element name="reinitialise_variables_after_first_adapt">
                      <attribute name="replaces">
                        <value>REINIT from solidity_options.inp</value>
                      </attribute>
                      <empty/>
                    </element>
                  </optional>
                </element>
              </optional>
            </element>
          </optional>
        </element>
      </optional>
      <optional>
        <choice>
          <a:documentation>Imported geometry for including solids in Fluidity simulations
At the moment geometries that can be used are cylinders, spheres
and external volumetric meshes.</a:documentation>
          <element name="imported_solids">
            <a:documentation>Information needed are a set of coordinates and 
radius for each particle.</a:documentation>
            <attribute name="name">
              <value>cylinders</value>
            </attribute>
            <ref name="input_solid_dynamics_cylinders"/>
            <optional>
              <element name="adapt_first">
                <element name="number_of_adapts">
                  <ref name="integer"/>
                </element>
              </element>
            </optional>
            <element name="Solid_Concentration_max">
              <ref name="real"/>
            </element>
            <element name="Solid_Absorption_factor">
              <ref name="real"/>
            </element>
            <element name="Solid_Density">
              <ref name="real"/>
            </element>
            <optional>
              <element name="visualize_concentrations">
                <empty/>
              </element>
            </optional>
            <optional>
              <element name="calculate_drag">
                <empty/>
              </element>
            </optional>
            <optional>
              <element name="output_drag">
                <empty/>
              </element>
            </optional>
          </element>
          <element name="imported_solids">
            <a:documentation>Information needed are a set of coordinates and 
radius for each particle. </a:documentation>
            <attribute name="name">
              <value>spheres</value>
            </attribute>
            <ref name="input_solid_dynamics_spheres"/>
            <optional>
              <element name="adapt_first">
                <element name="number_of_adapts">
                  <ref name="integer"/>
                </element>
              </element>
            </optional>
            <element name="Solid_Concentration_max">
              <ref name="real"/>
            </element>
            <element name="Solid_Absorption_factor">
              <ref name="real"/>
            </element>
            <element name="Solid_Density">
              <ref name="real"/>
            </element>
            <optional>
              <element name="visualize_concentrations">
                <empty/>
              </element>
            </optional>
            <optional>
              <element name="calculate_drag">
                <empty/>
              </element>
            </optional>
            <optional>
              <element name="output_drag">
                <empty/>
              </element>
            </optional>
          </element>
          <element name="imported_solids">
            <a:documentation>Information needed are a set of coordinates and 
radius for each particle, plus the number of 
superparticles and their connectivity</a:documentation>
            <attribute name="name">
              <value>super_particles</value>
            </attribute>
            <ref name="input_solid_dynamics_spheres"/>
            <optional>
              <element name="adapt_first">
                <element name="number_of_adapts">
                  <ref name="integer"/>
                </element>
              </element>
            </optional>
            <element name="Solid_Concentration_max">
              <ref name="real"/>
            </element>
            <element name="Solid_Absorption_factor">
              <ref name="real"/>
            </element>
            <element name="Solid_Density">
              <ref name="real"/>
            </element>
            <optional>
              <element name="visualize_concentrations">
                <empty/>
              </element>
            </optional>
            <optional>
              <element name="calculate_drag">
                <empty/>
              </element>
            </optional>
            <optional>
              <element name="output_drag">
                <empty/>
              </element>
            </optional>
          </element>
          <element name="imported_solids">
            <a:documentation>Information needed may come from external mesh
or from the 2Dfemdem input file </a:documentation>
            <attribute name="name">
              <value>external_2D_mesh</value>
            </attribute>
            <ref name="input_solid_dynamics_ext_mesh2D"/>
            <choice>
              <element name="mapping_type">
                <attribute name="name">
                  <value>brute_force</value>
                </attribute>
                <empty/>
              </element>
              <element name="mapping_type">
                <attribute name="name">
                  <value>fastest_n_to_n</value>
                </attribute>
                <element name="max_number_of_bins_x">
                  <a:documentation>As a rule of thumb, (Xmax-Xmin)/(number of bins_x) should be
greater than (at least twice) the maximum element size
of the fluid mesh (in the region where the particle is).
Same thing applies in Y and Z directions. Note that in some cases,
choosing the maximum element size for the whole fluid mesh 
might prove to slow down the mapping a bit.(bins might not have the 
optimal size)</a:documentation>
                  <ref name="integer"/>
                </element>
                <element name="max_number_of_bins_y">
                  <ref name="integer"/>
                </element>
                <element name="max_number_of_bins_z">
                  <ref name="integer"/>
                </element>
                <element name="bin_size_tolerance">
                  <a:documentation>Suggested value is 1e-10</a:documentation>
                  <ref name="real"/>
                </element>
              </element>
            </choice>
            <element name="area_checking_tol">
              <a:documentation>Tolerance value when using volume calculations
to determine if a given point is inside an element
or not.  
Suggested: 1e-10</a:documentation>
              <ref name="real"/>
            </element>
            <element name="volume_checking_tol">
              <a:documentation>Tolerance value when using volume calculations
to determine if a given point is inside an element
or not.  
Suggested: 1e-10</a:documentation>
              <ref name="real"/>
            </element>
            <optional>
              <element name="adapt_first">
                <element name="number_of_adapts">
                  <ref name="integer"/>
                </element>
              </element>
            </optional>
            <element name="Solid_Concentration_max">
              <ref name="real"/>
            </element>
            <element name="Solid_Absorption_factor">
              <ref name="real"/>
            </element>
            <element name="Solid_Density">
              <ref name="real"/>
            </element>
            <optional>
              <element name="visualize_concentrations">
                <empty/>
              </element>
            </optional>
            <optional>
              <element name="calculate_drag">
                <empty/>
              </element>
            </optional>
            <optional>
              <element name="output_drag">
                <empty/>
              </element>
            </optional>
          </element>
          <element name="imported_solids">
            <a:documentation>Information needed comes from two files
First file defines the geometry.
The second file defines the particle positions with respect to 
0,0,0 and their respective centers</a:documentation>
            <attribute name="name">
              <value>external_3D_mesh</value>
            </attribute>
            <ref name="input_solid_dynamics_ext_mesh3D"/>
            <choice>
              <element name="mapping_type">
                <attribute name="name">
                  <value>brute_force</value>
                </attribute>
                <empty/>
              </element>
              <element name="mapping_type">
                <attribute name="name">
                  <value>fastest_n_to_n</value>
                </attribute>
                <element name="max_number_of_bins_x">
                  <a:documentation>As a rule of thumb, (Xmax-Xmin)/(number of bins_x) should be
greater than (at least twice) the maximum element size
of the fluid mesh (in the region where the particle is).
Same thing applies in Y and Z directions. Note that in some cases,
choosing the maximum element size for the whole fluid mesh 
might prove to slow down the mapping a bit.(bins might not have the 
optimal size)</a:documentation>
                  <ref name="integer"/>
                </element>
                <element name="max_number_of_bins_y">
                  <ref name="integer"/>
                </element>
                <element name="max_number_of_bins_z">
                  <ref name="integer"/>
                </element>
                <element name="bin_size_tolerance">
                  <a:documentation>Suggested value is 1e-10</a:documentation>
                  <ref name="real"/>
                </element>
              </element>
            </choice>
            <element name="volume_checking_tol">
              <a:documentation>Tolerance value when using volume calculations
to determine if a given point is inside an element
or not.  
Suggested: 1e-10</a:documentation>
              <ref name="real"/>
            </element>
            <optional>
              <element name="adapt_first">
                <element name="number_of_adapts">
                  <ref name="integer"/>
                </element>
              </element>
            </optional>
            <element name="Solid_Concentration_max">
              <ref name="real"/>
            </element>
            <element name="Solid_Absorption_factor">
              <ref name="real"/>
            </element>
            <element name="Solid_Density">
              <ref name="real"/>
            </element>
            <optional>
              <element name="visualize_concentrations">
                <empty/>
              </element>
            </optional>
            <optional>
              <element name="calculate_drag">
                <empty/>
              </element>
            </optional>
            <optional>
              <element name="output_drag">
                <empty/>
              </element>
            </optional>
          </element>
        </choice>
      </optional>
      <optional>
        <element name="radiation">
          <a:documentation>Radiation Coupling
Options bellow are used in FETCH for different applications:
(i) nuclear reactors (KNOO), (ii) nuclear waste repository (NDA),
(iii) fissile solutions (SILENE and TRACY) and (iv) powders mixing
(JAEA). These options are mainly related to the mixing instructions
and cross-sections originally generated by WIMS</a:documentation>
          <element name="rt_time">
            <a:documentation>Time step subcycling used in EVENT</a:documentation>
            <optional>
              <element name="rt_subcycles">
                <a:documentation>Maximum number of subcycles</a:documentation>
                <attribute name="replaces">
                  <value>EVSBCY</value>
                </attribute>
                <ref name="integer"/>
              </element>
            </optional>
            <optional>
              <element name="rt_timestep_option">
                <a:documentation>Event time-stepping option
(=1) event; or fluidity</a:documentation>
                <attribute name="replaces">
                  <value>EVTIOP</value>
                </attribute>
                <ref name="integer"/>
              </element>
            </optional>
            <optional>
              <element name="rt_timestep_option1">
                <a:documentation>Event time-stepping factor 1</a:documentation>
                <attribute name="replaces">
                  <value>EVTIR1</value>
                </attribute>
                <ref name="real"/>
              </element>
            </optional>
            <optional>
              <element name="rt_timestep_option2">
                <a:documentation>Event time-stepping factor 2</a:documentation>
                <attribute name="replaces">
                  <value>EVTIR2</value>
                </attribute>
                <ref name="real"/>
              </element>
            </optional>
          </element>
          <element name="xsections_mixing_instructions">
            <a:documentation>Mesh-independent options used in the x-s generation and
mixing instructions</a:documentation>
            <optional>
              <element name="xs_no_energy_groups">
                <a:documentation>Number of energy groups</a:documentation>
                <attribute name="replaces">
                  <value>NGROUP</value>
                </attribute>
                <ref name="integer"/>
              </element>
            </optional>
            <optional>
              <element name="xs_no_neutrons_energy_groups">
                <a:documentation>Number of delayed neutron groups</a:documentation>
                <attribute name="replaces">
                  <value>NDELAY</value>
                </attribute>
                <ref name="integer"/>
              </element>
            </optional>
            <optional>
              <element name="xs_no_neutrons_energy_groups">
                <a:documentation>Number of temperature levels used in the xs generation</a:documentation>
                <attribute name="replaces">
                  <value>NDELAY</value>
                </attribute>
                <ref name="integer"/>
              </element>
            </optional>
            <optional>
              <element name="xs_volume_fraction">
                <a:documentation>Solid volume fraction used for the x-s generations</a:documentation>
                <attribute name="replaces">
                  <value>XMAPAK</value>
                </attribute>
                <ref name="real"/>
              </element>
            </optional>
            <optional>
              <element name="xs_void_limiting">
                <a:documentation>Limit after which x-s are effectively mixed with void</a:documentation>
                <attribute name="replaces">
                  <value>VOILIM</value>
                </attribute>
                <ref name="real"/>
              </element>
            </optional>
            <optional>
              <element name="xs_no_temperature">
                <a:documentation>Number of temperatures used in the XS generation</a:documentation>
                <attribute name="replaces">
                  <value>NMAT</value>
                </attribute>
                <ref name="integer"/>
              </element>
            </optional>
            <optional>
              <element name="xs_no_delayed_neutrons_temperature">
                <a:documentation>Number of temperature by delayed neutrons (really not sure)</a:documentation>
                <attribute name="replaces">
                  <value>NMATD</value>
                </attribute>
                <ref name="integer"/>
              </element>
            </optional>
            <optional>
              <element name="xs_dimension_mixing_instruction">
                <a:documentation>Dimensions associated with the mixing instructions</a:documentation>
                <attribute name="replaces">
                  <value>NDIMI</value>
                </attribute>
                <ref name="integer"/>
              </element>
            </optional>
            <optional>
              <element name="xs_dimension_mixing_instruction2">
                <a:documentation>Dimensions associated with the mixing instructions 2</a:documentation>
                <attribute name="replaces">
                  <value>NDSIMI</value>
                </attribute>
                <ref name="integer_dim_vector"/>
              </element>
            </optional>
            <optional>
              <element name="xs_mixing_option">
                <a:documentation>Option for mixing instructions</a:documentation>
                <attribute name="replaces">
                  <value>EVMXOP</value>
                </attribute>
                <ref name="integer"/>
              </element>
            </optional>
            <optional>
              <element name="xs_source_term1">
                <a:documentation>Source term1 for radiation
It might be necessary to change dimensio here as (nmatd,ndelay)</a:documentation>
                <attribute name="replaces">
                  <value>ILANDA</value>
                </attribute>
                <ref name="real_dim_vector"/>
              </element>
            </optional>
            <optional>
              <element name="xs_source_term1">
                <a:documentation>Source term2 for radiation</a:documentation>
                <attribute name="replaces">
                  <value>IBETA</value>
                </attribute>
                <ref name="real_dim_vector"/>
              </element>
            </optional>
            <optional>
              <element name="xs_temp">
                <a:documentation>Source from temperature interpolation</a:documentation>
                <attribute name="replaces">
                  <value>TEMMAT</value>
                </attribute>
                <ref name="real_dim_vector"/>
              </element>
            </optional>
          </element>
          <element name="radiation_transport_option">
            <a:documentation>Mesh-independent options used in the x-s generation and
mixing instructions</a:documentation>
            <optional>
              <element name="rt_energy_released">
                <a:documentation>Heat energy generated by fission</a:documentation>
                <attribute name="replaces">
                  <value>HEAPFI</value>
                </attribute>
                <ref name="real"/>
              </element>
            </optional>
            <optional>
              <element name="rt_gas_released">
                <a:documentation>Concentration of gas released (g of hydrogen) per fission event</a:documentation>
                <attribute name="replaces">
                  <value>COMPFI</value>
                </attribute>
                <ref name="real"/>
              </element>
            </optional>
            <optional>
              <element name="rt_gas_absorbed">
                <a:documentation>Concentration of gas absorbed per second (back reaction)</a:documentation>
                <attribute name="replaces">
                  <value>CONBAK</value>
                </attribute>
                <ref name="real"/>
              </element>
            </optional>
            <optional>
              <element name="rt_gas_radiolytic">
                <a:documentation>Concentration of radiolytic gas at the bubble surface</a:documentation>
                <attribute name="replaces">
                  <value>BUBZER</value>
                </attribute>
                <ref name="real"/>
              </element>
            </optional>
            <optional>
              <element name="rt_gamma_boussinesq">
                <a:documentation>Expansion coefficient: it is actually the Gamma in the Boussinesq
approximation</a:documentation>
                <attribute name="replaces">
                  <value>EXPCOE</value>
                </attribute>
                <ref name="real"/>
              </element>
            </optional>
          </element>
        </element>
      </optional>
    </element>
  </start>
  <!-- Allow the user to attach a comment to any value in the xml file. -->
  <define name="comment">
    <optional>
      <element name="comment">
        <data type="string"/>
      </element>
    </optional>
  </define>
  <define name="anystring">
    <element name="string_value">
      <!--
        Lines is a hint to the gui about the size of the text box.
        It is not an enforced limit on string length.
      -->
      <attribute name="lines">
        <value>1</value>
      </attribute>
      <data type="string"/>
    </element>
    <ref name="comment"/>
  </define>
  <define name="filename">
    <element name="string_value">
      <attribute name="type">
        <value>filename</value>
      </attribute>
      <attribute name="lines">
        <value>1</value>
      </attribute>
      <data type="string"/>
    </element>
    <ref name="comment"/>
  </define>
  <define name="python_code">
    <element name="string_value">
      <attribute name="type">
        <value>python</value>
      </attribute>
      <attribute name="lines">
        <value>20</value>
      </attribute>
      <data type="string"/>
    </element>
    <ref name="comment"/>
  </define>
  <define name="logical">
    <element name="logical_value">
      <attribute name="rank">
        <value>0</value>
      </attribute>
      <list>
        <data type="boolean"/>
      </list>
    </element>
    <ref name="comment"/>
  </define>
  <define name="integer">
    <element name="integer_value">
      <attribute name="rank">
        <value>0</value>
      </attribute>
      <list>
        <data type="integer"/>
      </list>
    </element>
    <ref name="comment"/>
  </define>
  <define name="integer_vector">
    <element name="integer_value">
      <attribute name="rank">
        <value>1</value>
      </attribute>
      <attribute name="shape">
        <data type="integer"/>
      </attribute>
      <list>
        <oneOrMore>
          <data type="integer"/>
        </oneOrMore>
      </list>
    </element>
    <ref name="comment"/>
  </define>
  <define name="integer_tensor">
    <element name="integer_value">
      <attribute name="rank">
        <value>2</value>
      </attribute>
      <attribute name="shape">
        <list>
          <data type="integer"/>
          <data type="integer"/>
        </list>
      </attribute>
      <list>
        <oneOrMore>
          <data type="integer"/>
        </oneOrMore>
      </list>
    </element>
    <ref name="comment"/>
  </define>
  <!-- An integer vector of length dim -->
  <define name="integer_dim_vector">
    <element name="integer_value">
      <attribute name="rank">
        <value>1</value>
      </attribute>
      <!--
        Setting dim1 to a function of dim allows the gui to set the
        vector to the right length.
      -->
      <attribute name="dim1">
        <value>dim</value>
      </attribute>
      <attribute name="shape">
        <data type="integer"/>
      </attribute>
      <list>
        <oneOrMore>
          <data type="integer"/>
        </oneOrMore>
      </list>
    </element>
    <ref name="comment"/>
  </define>
  <!-- An dim x dim integer matrix (rank 2 tensor). -->
  <define name="integer_dim_tensor">
    <element name="integer_value">
      <attribute name="rank">
        <value>2</value>
      </attribute>
      <!--
        Setting dim1, dim2 to a function of dim allows the gui to set the
        tensor to the right shape.
      -->
      <attribute name="dim1">
        <value>dim</value>
      </attribute>
      <attribute name="dim2">
        <value>dim</value>
      </attribute>
      <attribute name="shape">
        <list>
          <data type="integer"/>
          <data type="integer"/>
        </list>
      </attribute>
      <list>
        <oneOrMore>
          <data type="integer"/>
        </oneOrMore>
      </list>
    </element>
    <ref name="comment"/>
  </define>
  <define name="real">
    <element name="real_value">
      <attribute name="rank">
        <value>0</value>
      </attribute>
      <list>
        <data type="float"/>
      </list>
    </element>
    <ref name="comment"/>
  </define>
  <!-- An arbitrary length real vector -->
  <define name="real_vector">
    <element name="real_value">
      <attribute name="rank">
        <value>1</value>
      </attribute>
      <attribute name="shape">
        <data type="float"/>
      </attribute>
      <list>
        <oneOrMore>
          <data type="float"/>
        </oneOrMore>
      </list>
    </element>
    <ref name="comment"/>
  </define>
  <!-- An arbitrary size real matrix (rank 2 tensor). -->
  <define name="real_tensor">
    <element name="real_value">
      <attribute name="rank">
        <value>2</value>
      </attribute>
      <attribute name="shape">
        <list>
          <data type="integer"/>
          <data type="integer"/>
        </list>
      </attribute>
      <list>
        <oneOrMore>
          <data type="float"/>
        </oneOrMore>
      </list>
    </element>
    <ref name="comment"/>
  </define>
  <!-- A real vector of length dim -->
  <define name="real_dim_vector">
    <element name="real_value">
      <attribute name="rank">
        <value>1</value>
      </attribute>
      <!--
        Setting dim1 to a function of dim allows the gui to set the
        vector to the right length.
      -->
      <attribute name="dim1">
        <value>dim</value>
      </attribute>
      <attribute name="shape">
        <data type="integer"/>
      </attribute>
      <list>
        <oneOrMore>
          <data type="float"/>
        </oneOrMore>
      </list>
    </element>
    <ref name="comment"/>
  </define>
  <!-- A real vector of length dim minus one -->
  <define name="real_dim_minus_one_vector">
    <element name="real_value">
      <attribute name="rank">
        <value>1</value>
      </attribute>
      <!--
        Setting dim1 to a function of dim allows the gui to set the
        vector to the right length.
      -->
      <attribute name="dim1">
        <value>dim-1</value>
      </attribute>
      <attribute name="shape">
        <data type="integer"/>
      </attribute>
      <list>
        <oneOrMore>
          <data type="float"/>
        </oneOrMore>
      </list>
    </element>
    <ref name="comment"/>
  </define>
  <!-- A dim x dim real matrix (rank 2 tensor). -->
  <define name="real_dim_tensor">
    <element name="real_value">
      <attribute name="symmetric">
        <value>false</value>
      </attribute>
      <attribute name="rank">
        <value>2</value>
      </attribute>
      <!--
        Setting dim1, dim2 to a function of dim allows the gui to set the
        tensor to the right shape.
      -->
      <attribute name="dim1">
        <value>dim</value>
      </attribute>
      <attribute name="dim2">
        <value>dim</value>
      </attribute>
      <attribute name="shape">
        <list>
          <data type="integer"/>
          <data type="integer"/>
        </list>
      </attribute>
      <list>
        <oneOrMore>
          <data type="float"/>
        </oneOrMore>
      </list>
    </element>
    <ref name="comment"/>
  </define>
  <!-- A dim x dim real matrix (rank 2 tensor) constrained to be symmetric. -->
  <define name="real_dim_symmetric_tensor">
    <element name="real_value">
      <attribute name="symmetric">
        <value>true</value>
      </attribute>
      <attribute name="rank">
        <value>2</value>
      </attribute>
      <attribute name="dim1">
        <value>dim</value>
      </attribute>
      <attribute name="dim2">
        <value>dim</value>
      </attribute>
      <attribute name="shape">
        <list>
          <data type="integer"/>
          <data type="integer"/>
        </list>
      </attribute>
      <list>
        <oneOrMore>
          <data type="float"/>
        </oneOrMore>
      </list>
    </element>
    <ref name="comment"/>
  </define>
  <!-- Choice of input method, e.g. for boundary conditions -->
  <define name="input_choice_real">
    <choice>
      <element name="constant">
        <a:documentation>Constant value</a:documentation>
        <ref name="real"/>
      </element>
      <element name="generic_function">
        <a:documentation>Generic function prescribing real input</a:documentation>
        <ref name="anystring"/>
      </element>
      <element name="python">
        <a:documentation>Python function prescribing real input. Functions should be of the form:

def val(X, t):
   # Function code
   return # Return value

where X is a tuple of length geometry dimension.</a:documentation>
        <ref name="python_code"/>
      </element>
    </choice>
  </define>
  <!--
    Choice of input method for initial conditions
    Note: combine = "choice" should be used here to combine with input_choice_real, but Diamond doesn't support it
  -->
  <define name="input_choice_initial_condition_real">
    <choice>
      <element name="constant">
        <a:documentation>Constant value</a:documentation>
        <ref name="real"/>
      </element>
      <element name="generic_function">
        <a:documentation>Generic function prescribing real input</a:documentation>
        <ref name="anystring"/>
      </element>
      <element name="python">
        <a:documentation>Python function prescribing real input. Functions should be of the form:

def val(X, t):
   # Function code
   return # Return value

where X is a tuple of length geometry dimension.</a:documentation>
        <ref name="python_code"/>
      </element>
      <element name="from_file">
        <a:documentation>Initialise the field from an existing file (indended primarily for use in checkpointing). The file mesh must match the mesh of this field.</a:documentation>
        <attribute name="file_name">
          <data type="string"/>
        </attribute>
        <element name="format">
          <a:documentation>The format of the input file containing field data.</a:documentation>
          <element name="string_value">
            <value>vtu</value>
          </element>
        </element>
        <ref name="comment"/>
      </element>
    </choice>
  </define>
  <!-- Choice of input method, e.g. for boundary conditions -->
  <define name="input_choice_real_dim_vector">
    <choice>
      <element name="constant">
        <a:documentation>Constant value</a:documentation>
        <ref name="real_dim_vector"/>
      </element>
      <!--
        ## Generic function prescribing dimensional vector input
        element generic_function {
           anystring
        }|
      -->
      <element name="python">
        <a:documentation>Python function prescribing dimensional vector input. Functions should be of the form:

def val(X, t):
   # Function code
   return # Return value

where X and the return value are tuples of length geometry dimension.</a:documentation>
        <ref name="python_code"/>
      </element>
    </choice>
  </define>
  <!--
    Choice of input method, e.g. for boundary conditions
    this one specifies a vector field of dim minus one
  -->
  <define name="input_choice_real_dim_minus_one_vector">
    <choice>
      <element name="constant">
        <a:documentation>Constant value</a:documentation>
        <ref name="real_dim_minus_one_vector"/>
      </element>
      <!--
        ## Generic function prescribing dimensional vector input
        element generic_function {
           anystring
        }|
      -->
      <element name="python">
        <a:documentation>Python function prescribing dimensional vector input. Functions should be of the form:

def val(X, t):
   # Function code
   return # Return value

where X and the return value are tuples of length geometry dimension.</a:documentation>
        <ref name="python_code"/>
      </element>
    </choice>
  </define>
  <!--
    Choice of input method for initial conditions
    Note: combine = "choice" should be used here to combine with input_choice_real, but Diamond doesn't support it
  -->
  <define name="input_choice_initial_condition_vector">
    <choice>
      <element name="constant">
        <a:documentation>Constant value</a:documentation>
        <ref name="real_dim_vector"/>
      </element>
      <!--
        ## Generic function prescribing dimensional vector input
        element generic_function {
           anystring
        }|
      -->
      <element name="python">
        <a:documentation>Python function prescribing dimensional vector input. Functions should be of the form:

def val(X, t):
   # Function code
   return # Return value

where X and the return value are tuples of length geometry dimension.</a:documentation>
        <ref name="python_code"/>
      </element>
      <element name="from_file">
        <a:documentation>Initialise the field from an existing file (indended primarily for use in checkpointing). The file mesh must match the mesh of this field.</a:documentation>
        <attribute name="file_name">
          <data type="string"/>
        </attribute>
        <element name="format">
          <a:documentation>The format of the input file containing field data.</a:documentation>
          <element name="string_value">
            <value>vtu</value>
          </element>
        </element>
        <ref name="comment"/>
      </element>
    </choice>
  </define>
  <!--
    Choice of input method for initial/boundary conditions
    version for real symmetric tensor
  -->
  <define name="input_choice_real_dim_symmetric_tensor">
    <element name="constant">
      <a:documentation>Constant symmetric tensor</a:documentation>
      <ref name="real_dim_symmetric_tensor"/>
    </element>
    <!--
           }|
           ## Generic function prescribing symmetric tensor input
           element generic_function {
              anystring
           }|
           ## Python command prescribing symmetric tensor input.
           ## Not yet implemented.
           element python {
              python_code
           }
    -->
  </define>
  <!--
    Choice of input method for initial/boundary conditions
    version for real tensor
  -->
  <define name="input_choice_real_dim_tensor">
    <element name="constant">
      <a:documentation>Constant tensor</a:documentation>
      <ref name="real_dim_tensor"/>
    </element>
    <!--
           }|
           ## Generic function prescribing tensor input
           element generic_function {
              anystring
           }|
           ## Python command prescribing tensor input.
           ## Not yet implemented.
           element python {
              python_code
           }
    -->
  </define>
  <define name="prognostic_velocity_field">
    <element name="spatial_discretisation">
      <a:documentation>Spatial discretisation options</a:documentation>
      <choice>
        <element name="continuous_galerkin">
          <a:documentation>Use a finite element discretisation - needs to be fleshed out</a:documentation>
          <attribute name="replaces">
            <value>DISOPT</value>
          </attribute>
          <choice>
            <element name="balancing_diffusion_x">
              <a:documentation>balancing diffusion based on (x,y) space.</a:documentation>
              <attribute name="replaces">
                <value>DISOPT = 1</value>
              </attribute>
              <empty/>
            </element>
            <element name="laxwendroff_balancing_diffusion">
              <a:documentation>Laxwendrof balancing diffusion.</a:documentation>
              <attribute name="replaces">
                <value>DISOPT = 2</value>
              </attribute>
              <empty/>
            </element>
            <element name="balancing_diffusion_xt">
              <a:documentation>(x,y,t) -balancing diffusion.</a:documentation>
              <attribute name="replaces">
                <value>DISOPT = 3</value>
              </attribute>
              <empty/>
            </element>
            <element name="no_balancing_diffusion">
              <a:documentation>No balancing diffusion.</a:documentation>
              <attribute name="replaces">
                <value>DISOPT = 4</value>
              </attribute>
              <empty/>
            </element>
            <element name="nonlinear_streamline_w_crossstream_diffusion">
              <a:documentation>nonlinear streamline and cross stream diffusion.</a:documentation>
              <attribute name="replaces">
                <value>DISOPT = 5</value>
              </attribute>
              <empty/>
            </element>
            <element name="nonlinear_upwind_steepest">
              <a:documentation>nonlinear upwind in steapest direction.</a:documentation>
              <attribute name="replaces">
                <value>DISOPT = 6</value>
              </attribute>
              <empty/>
            </element>
            <element name="nonlinear_streamline_w_restricted_crossstream_diffusion">
              <a:documentation>nonlinear streamline+ cross stream diffusion(but restricted)</a:documentation>
              <attribute name="replaces">
                <value>DISOPT = 7</value>
              </attribute>
              <empty/>
            </element>
            <element name="les_constant_length_scale">
              <a:documentation>LES option using constant length scale.</a:documentation>
              <attribute name="replaces">
                <value>DISOPT = 42</value>
              </attribute>
              <empty/>
            </element>
            <element name="les_isotropic_length_scale">
              <a:documentation>LES option using isotropic length scale.</a:documentation>
              <attribute name="replaces">
                <value>DISOPT = 43</value>
              </attribute>
              <empty/>
            </element>
            <element name="les_no_balancing_diffusion">
              <a:documentation>LES option which uses no balancing diffusion.</a:documentation>
              <attribute name="replaces">
                <value>DISOPT = 44</value>
              </attribute>
              <empty/>
            </element>
            <element name="les_no_balancing_diffusion_2">
              <a:documentation>LES option which uses no balancing diffusion.</a:documentation>
              <attribute name="replaces">
                <value>DISOPT = 45</value>
              </attribute>
              <empty/>
            </element>
            <element name="les_no_balancing_diffusion_fourth_order_dissipation">
              <a:documentation>same as 45 but with 4th order dissipation.</a:documentation>
              <attribute name="replaces">
                <value>DISOPT = 46</value>
              </attribute>
              <empty/>
            </element>
            <element name="les_tensor_form">
              <a:documentation>LES but in tensor form like hart3d</a:documentation>
              <attribute name="replaces">
                <value>DISOPT = 47</value>
              </attribute>
              <empty/>
            </element>
            <element name="les_fourth_order">
              <a:documentation>LES 4th order version of 47</a:documentation>
              <attribute name="replaces">
                <value>DISOPT = 48</value>
              </attribute>
              <empty/>
            </element>
            <element name="no_balancing_diffusion_remove_nonlinear_terms">
              <a:documentation>NO balancing diffusion(DISOPT=4)and take out non-linear terms.</a:documentation>
              <attribute name="replaces">
                <value>DISOPT = 125</value>
              </attribute>
              <empty/>
            </element>
          </choice>
          <optional>
            <element name="lump_mass_matrix">
              <a:documentation>Lump the mass matrix in the momentum equation</a:documentation>
              <attribute name="replaces">
                <value>MLUMP</value>
              </attribute>
              <empty/>
            </element>
          </optional>
        </element>
        <element name="discontinuous_galerkin">
          <a:documentation>Discontinuous galerkin formulation. This causes Momentum_DG to be
called instead of diff3d. Confusingly it is not necessary to provide
a discontinuous velocity field for this to work!</a:documentation>
          <attribute name="replaces">
            <value>DISOPT</value>
          </attribute>
          <element name="viscosity_scheme">
            <choice>
              <element name="bassi_rebay">
                <a:documentation>Classical scheme from Bassi and Rebay 
(JCP 131 267-179 1997)</a:documentation>
                <empty/>
              </element>
              <element name="arbitrary_upwind">
                <a:documentation>Scheme in which upwinding is applied in
alternating directions. Devised by C.Pain.</a:documentation>
                <empty/>
              </element>
            </choice>
          </element>
          <element name="advection_scheme">
            <choice>
              <element name="upwind">
                <a:documentation>Straightforward upwinding of the nonlinear velocity.</a:documentation>
                <empty/>
              </element>
              <element name="none">
                <a:documentation>Disable advection</a:documentation>
                <empty/>
              </element>
            </choice>
          </element>
        </element>
        <ref name="spatial_control_volume_options"/>
        <element name="legacy_discretisation">
          <element name="legacy_disopt">
            <a:documentation>Legacy discretisation option (DISOPT)

From diff3d comments (other possibilities are known to exist!):
==============================================================
DISOPT=1 - balancing diffusion based on (x,y) space.
DISOPT=2 - Laxwendrof balancing diffusion.
DISOPT=3 - (x,y,t) -balancing diffusion.
DISOPT=4 - No balancing diffusion.
DISOPT=5 - nonlinear streamline and cross stream diffusion.
DISOPT=6 - nonlinear upwind in steapest direction.
DISOPT=7 - nonlinear streamline+ cross stream diffusion(but restricted)

DISOPT=42- LES option using constant length scale.
DISOPT=43- LES option using isotropic length scale.
DISOPT=44- LES option which uses no balancing diffusion.
DISOPT=45- LES option which uses no balancing diffusion.
DISOPT=46- same as 45 but with 4th order dissipation.
DISOPT=47 -LES but in tensor form like hart3d.
DISOPT=48 -LES 4th order version of 47.

DISOPT=125 - NO balancing diffusion(DISOPT=4)and take out non-linear terms.</a:documentation>
            <attribute name="replaces">
              <value>DISOPT</value>
            </attribute>
            <ref name="integer"/>
          </element>
          <optional>
            <element name="legacy_mlump">
              <a:documentation>Lump the mass matrix in the momentum equation</a:documentation>
              <attribute name="replaces">
                <value>MLUMP</value>
              </attribute>
              <empty/>
            </element>
          </optional>
          <optional>
            <element name="legacy_sufmom">
              <a:documentation>have a surface integral for the momentum equations.
Manual suggests false</a:documentation>
              <attribute name="replaces">
                <value>SUFMOM</value>
              </attribute>
              <empty/>
            </element>
          </optional>
          <optional>
            <element name="legacy_ndisop">
              <a:documentation>Legacy discretisation option for control volume advection of momentum (DISOPT)
Set to 0 if not activated
          Method for face-value est.   Time-stepping     Limiting
------------------------------------------------------------------
  =0      1st order in space          Theta=specified    UNIVERSAL
  =1      1st order in space          Theta=non-linear   UNIVERSAL
  =2      Trapazoidal rule in space   Theta=specified    UNIVERSAL
  =3      Trapazoidal rule in space   Theta=non-linear   UNIVERSAL
  =4      Finite elements in space    Theta=specified    UNIVERSAL
  =5      Finite elements in space    Theta=non-linear   UNIVERSAL
  =6      Finite elements in space    Theta=specified    NONE
  =7      Finite elements in space    Theta=non-linear   NONE
  =8      Finite elements in space    Theta=specified    DOWNWIND+
  =9      Finite elements in space    Theta=non-linear   DOWNWIND+</a:documentation>
              <attribute name="replaces">
                <value>NDISOP</value>
              </attribute>
              <ref name="integer"/>
            </element>
          </optional>
        </element>
      </choice>
      <element name="conservative_advection">
        <a:documentation>Conservative discretisation of momentum equations
BETA=1. -- conservative (divergence form)
BETA=0. -- non-conservative
0. &lt; BETA &lt; 1.</a:documentation>
        <attribute name="replaces">
          <value>BETA</value>
        </attribute>
        <ref name="real"/>
      </element>
      <optional>
        <element name="couple_velocity_components">
          <a:documentation>Have the velocity components coupled through the momentum matrix.
Manual suggests false</a:documentation>
          <attribute name="replaces">
            <value>VARVIS</value>
          </attribute>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="legacy_ocedra">
          <a:documentation>Bottom drag switch</a:documentation>
          <attribute name="replaces">
            <value>OCEDRA</value>
          </attribute>
          <ref name="integer"/>
        </element>
      </optional>
      <optional>
        <element name="inner_element">
          <a:documentation>Candy and Pain's subgridscale model.
At this stage this only works if you select continuous galerkin above.</a:documentation>
          <attribute name="replaces">
            <value>NSUBVLOC, NSUBNVLOC</value>
          </attribute>
          <optional>
            <element name="use_quadratic_pressure">
              <attribute name="replaces">
                <value>PREOPT=PREOPT+1000</value>
              </attribute>
            </element>
          </optional>
          <optional>
            <element name="use_dg_hack">
              <attribute name="replaces">
                <value>PREOPT=PREOPT+10000</value>
              </attribute>
            </element>
          </optional>
        </element>
      </optional>
    </element>
    <element name="temporal_discretisation">
      <a:documentation>Temporal discretisation options</a:documentation>
      <element name="theta">
        <a:documentation>Implicit/explicit control (THETA)
=0.  -- explicit
=0.5 -- Crank-Nicholson
=1.  -- implicit</a:documentation>
        <attribute name="replaces">
          <value>THETA</value>
        </attribute>
        <ref name="real"/>
      </element>
      <optional>
        <ref name="temporal_control_volume_options"/>
      </optional>
      <element name="relaxation">
        <a:documentation>Non-linear relaxation term
=0.  -- previous timestep velocity solution used in non-linear terms of momentum equations
=1.  -- previous iteration velocity solution used in non-linear terms of momentum equations
0. &lt; ITHETA &lt; 1.</a:documentation>
        <attribute name="replaces">
          <value>ITHETA</value>
        </attribute>
        <ref name="real"/>
      </element>
      <optional>
        <element name="explicit_advection">
          <a:documentation>Treat advection terms explicity and therefore make matrix symmetric</a:documentation>
          <attribute name="replaces">
            <value>MAKSYM</value>
          </attribute>
        </element>
      </optional>
    </element>
    <element name="solver">
      <a:documentation>Solver</a:documentation>
      <ref name="linear_solver_options"/>
      <optional>
        <element name="legacy">
          <a:documentation>Legacy solver options
If selected legacy solvers solcg and gmres will be used
to solve the linear equations, otherwise PETSc is used.</a:documentation>
          <element name="max_iterations_outer">
            <a:documentation>Maximum number of iterations for solution of momentum
From manual: DDM iterations if parallel solution (TBD)
Manual suggests 100</a:documentation>
            <attribute name="replaces">
              <value>MOMNO1</value>
            </attribute>
            <ref name="integer"/>
          </element>
          <element name="max_iterations_inner">
            <a:documentation>Maximum number of iterations for solution of momentum
From manual: internal iterations if parallel solution (TBD)
Manual suggests 100</a:documentation>
            <attribute name="replaces">
              <value>MOMNO2</value>
            </attribute>
            <ref name="integer"/>
          </element>
          <element name="max_nonrestarted_iterations_outer">
            <a:documentation>Maximum number of non-restarted outer iterations for solution of momentum (TBD)
Manual suggests 10</a:documentation>
            <attribute name="replaces">
              <value>MINTE1</value>
            </attribute>
            <ref name="integer"/>
          </element>
          <element name="max_nonrestarted_iterations_inner">
            <a:documentation>Maximum number of non-restarted inner iterations for solution of momentum (TBD)
Manual suggests 10</a:documentation>
            <attribute name="replaces">
              <value>MINTE2</value>
            </attribute>
            <ref name="integer"/>
          </element>
          <element name="max_iterations_inner_minnoi">
            <a:documentation>Maximum number of inner iterations for solution of momentum  (TBD)
Manual suggests 100</a:documentation>
            <attribute name="replaces">
              <value>MINNOI</value>
            </attribute>
            <ref name="integer"/>
          </element>
          <element name="tolerance_inner_minerr">
            <a:documentation>Tolerance for solution of momentum (inner iterations) (TBD)
Manual suggests 1.E-10</a:documentation>
            <attribute name="replaces">
              <value>MINERR</value>
            </attribute>
            <ref name="real"/>
          </element>
          <element name="tolerance_outer">
            <a:documentation>Tolerance for solution of momentum (outer iterations)
Manual suggests 1.E-10</a:documentation>
            <attribute name="replaces">
              <value>MOMER1</value>
            </attribute>
            <ref name="real"/>
          </element>
          <element name="tolerance_inner">
            <a:documentation>Tolerance for solution of momentum (inner iterations)
Manual suggests 1.E-10</a:documentation>
            <attribute name="replaces">
              <value>MOMER2</value>
            </attribute>
            <ref name="real"/>
          </element>
        </element>
      </optional>
    </element>
    <ref name="constitutive_laws"/>
    <oneOrMore>
      <choice>
        <element name="initial_condition">
          <a:documentation>Initial condition for WholeMesh
Only specify one condition if not using mesh regions.
Otherwise select other initial_condition option, specify region_ids
and distinct names.  Then add extra intial conditions for other regions.</a:documentation>
          <attribute name="name">
            <value>WholeMesh</value>
          </attribute>
          <ref name="input_choice_initial_condition_vector"/>
        </element>
        <element name="initial_condition">
          <a:documentation>Multiple initial_conditions are allowed if specifying different values in different
regions of the mesh (defined by region_ids).  In this case each initial_condition
requires a distinct name for the options dictionary.</a:documentation>
          <attribute name="name">
            <data type="string" datatypeLibrary=""/>
          </attribute>
          <ref name="region_ids"/>
          <ref name="input_choice_initial_condition_vector"/>
        </element>
      </choice>
    </oneOrMore>
    <zeroOrMore>
      <element name="boundary_conditions">
        <a:documentation>Boundary conditions</a:documentation>
        <attribute name="replaces">
          <value>boundary, TMPER1 TMPER2 TMPERI</value>
        </attribute>
        <attribute name="name">
          <data type="string" datatypeLibrary=""/>
        </attribute>
        <element name="surface_ids">
          <a:documentation>Surface id:</a:documentation>
          <ref name="integer_vector"/>
        </element>
        <ref name="velocity_boundary_conditions"/>
      </element>
    </zeroOrMore>
    <optional>
      <element name="tensor_field">
        <a:documentation>For a Newtonian fluid this is the shear viscosity.</a:documentation>
        <attribute name="replaces">
          <value>MUPTXX MUPTYY MUPTZZ MUPTYZ MUPTXZ MUPTXY RMUPXX RMUPYY RMUPZZ RMUPYZ RMUPXZ RMUPXY CONMU ALLMU TWOMU ONEMU</value>
        </attribute>
        <attribute name="name">
          <value>Viscosity</value>
        </attribute>
        <attribute name="rank">
          <value>2</value>
        </attribute>
        <choice>
          <element name="prescribed">
            <ref name="prescribed_values_tensor_field"/>
          </element>
          <element name="diagnostic">
            <ref name="diagnostic_tensor_field"/>
          </element>
        </choice>
      </element>
    </optional>
    <optional>
      <element name="vector_field">
        <a:documentation>Source</a:documentation>
        <attribute name="name">
          <value>Source</value>
        </attribute>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="replaces">
          <value>CONSOX CONSOY CONSOZ RONSOX RONSOY RONSOZ ZSOX ZSOY ZSOZ</value>
        </attribute>
        <choice>
          <element name="prescribed">
            <ref name="prescribed_vector_field_no_adapt"/>
          </element>
          <element name="diagnostic">
            <ref name="diagnostic_vector_field"/>
          </element>
        </choice>
        <optional>
          <element name="lump_source">
            <attribute name="replaces">
              <value>SLUMP</value>
            </attribute>
            <empty/>
          </element>
        </optional>
      </element>
    </optional>
    <optional>
      <element name="vector_field">
        <a:documentation>Absorption</a:documentation>
        <attribute name="name">
          <value>Absorption</value>
        </attribute>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="replaces">
          <value>XABSZE YABSZE ZABSZE XABS YABS ZABS XABSOR YABSOR ZABSOR XABSCO YABSCO ZABSCO</value>
        </attribute>
        <choice>
          <element name="prescribed">
            <ref name="prescribed_vector_field_no_adapt"/>
          </element>
          <element name="diagnostic">
            <ref name="diagnostic_vector_field"/>
          </element>
        </choice>
        <optional>
          <element name="lump_absorption">
            <a:documentation>Lump the inclusion of absorbtion terms.
Manual suggests false</a:documentation>
            <attribute name="replaces">
              <value>ABSLUM</value>
            </attribute>
            <empty/>
          </element>
        </optional>
      </element>
    </optional>
    <optional>
      <element name="tensor_field">
        <a:documentation>Elastic parameters for elastic and visco-elastic materials
For a linearly elastic solid
In legacy elastic solids were run with SOLIDS = 2 from solidity_options.inp.
In gem ONEMU and CONMU = .TRUE.
and RMUPZZ taken as the isotropic Young's modulus
UNDER DEVELOPMENT
- currently only works for lagrangian meshes
- only single materials tested so far
- momentum equations assembled in solid3d so not all
  discretisation options above are valid</a:documentation>
        <attribute name="replaces">
          <value>SOLIDS = 1 from solidity_options.inp</value>
        </attribute>
        <attribute name="name">
          <value>Elasticity</value>
        </attribute>
        <attribute name="rank">
          <value>2</value>
        </attribute>
        <choice>
          <element name="prescribed">
            <ref name="prescribed_values_tensor_field"/>
          </element>
          <element name="diagnostic">
            <ref name="diagnostic_tensor_field"/>
          </element>
        </choice>
      </element>
    </optional>
    <optional>
      <element name="scalar_field">
        <a:documentation>Cohesion for plastic materials
UNDER DEVELOPMENT
- currently only works for lagrangian meshes
- only single materials tested so far
- momentum equations assembled in solid3d so not all
  discretisation options above are valid</a:documentation>
        <attribute name="name">
          <value>Cohesion</value>
        </attribute>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="replaces">
          <value>COHESI from solidity_options.inp</value>
        </attribute>
        <choice>
          <element name="prescribed">
            <ref name="prescribed_scalar_field_no_adapt"/>
          </element>
          <element name="diagnostic">
            <ref name="diagnostic_scalar_field"/>
          </element>
        </choice>
      </element>
    </optional>
    <optional>
      <element name="scalar_field">
        <a:documentation>Friction Angle for plastic materials
UNDER DEVELOPMENT
- currently only works for lagrangian meshes
- only single materials tested so far
- momentum equations assembled in solid3d so not all
  discretisation options above are valid</a:documentation>
        <attribute name="name">
          <value>FrictionAngle</value>
        </attribute>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="replaces">
          <value>FRCANG from solidity_options.inp</value>
        </attribute>
        <choice>
          <element name="prescribed">
            <ref name="prescribed_scalar_field_no_adapt"/>
          </element>
          <element name="diagnostic">
            <ref name="diagnostic_scalar_field"/>
          </element>
        </choice>
      </element>
    </optional>
    <optional>
      <element name="test_timestep_accuracy">
        <a:documentation>Adaptive timestepping option
Test accuracy of velocity and determines a new timestep
Only used in multiphase and must have adaptive timestepping activated.</a:documentation>
        <attribute name="replaces">
          <value>UVWADP = TRUE</value>
        </attribute>
        <empty/>
      </element>
    </optional>
    <ref name="prognostic_vector_output_options"/>
    <ref name="prognostic_vector_stat_options"/>
    <ref name="vector_convergence_options"/>
    <ref name="adaptivity_options_vector_field"/>
  </define>
  <define name="prognostic_scalar_field">
    <choice>
      <element name="equation">
        <a:documentation>Select the equation used to solve for this field.
Advection Diffusion is the norm for scalar fields.
Works for all discretisation types.</a:documentation>
        <attribute name="name">
          <value>AdvectionDiffusion</value>
        </attribute>
      </element>
      <element name="equation">
        <a:documentation>***UNDER TESTING***
Select the equation used to solve for this field.
Advection equation.
ONLY WORKS FOR CONTROL VOLUME DISCRETISATIONS WITHOUT A
DIFFUSIVITY, SOURCE OR ABSORPTION.</a:documentation>
        <attribute name="name">
          <value>Advection</value>
        </attribute>
      </element>
      <element name="equation">
        <a:documentation>***UNDER TESTING***
Select the equation used to solve for this field.
Conservation of Mass equation - requires the selection of a Density field.
ONLY WORKS FOR CONTROL VOLUME DISCRETISATIONS WITHOUT A
DIFFUSIVITY, SOURCE OR ABSORPTION.</a:documentation>
        <attribute name="name">
          <value>ConservationOfMass</value>
        </attribute>
        <choice>
          <element name="density">
            <a:documentation>Select density to use in the Conservation of Mass Equation
Use the MaterialDensity - useful for multimaterial simulations
Clearly this requires a MaterialDensity field to be present</a:documentation>
            <attribute name="name">
              <value>MaterialDensity</value>
            </attribute>
          </element>
          <element name="density">
            <a:documentation>Select density to use in the Conservation of Mass Equation
Use the bulk Density
Clearly this requires a Density field to be present</a:documentation>
            <attribute name="name">
              <value>Density</value>
            </attribute>
          </element>
          <element name="density">
            <a:documentation>Select density to use in the Conservation of Mass Equation</a:documentation>
            <attribute name="name">
              <data type="string" datatypeLibrary=""/>
            </attribute>
          </element>
        </choice>
      </element>
      <element name="equation">
        <a:documentation>***UNDER TESTING***
Select the equation used to solve for this field.
Reduced Conservation of Mass equation - requires the selection of a Density field.
ONLY WORKS FOR CONTROL VOLUME DISCRETISATIONS WITHOUT A
DIFFUSIVITY, SOURCE OR ABSORPTION.
This equation is very similar to a standard conservation of mass equation
except that the time discretisation uses only a single time level of density.
This enables consistency between the MaterialVolumeFraction (ReducedConservationOfMass) and 
MaterialDensity (Advection) equations in compressible multimaterial simulations.</a:documentation>
        <attribute name="name">
          <value>ReducedConservationOfMass</value>
        </attribute>
        <choice>
          <element name="density">
            <a:documentation>Select density to use in the Reduced Conservation of Mass Equation
Use the MaterialDensity - useful for multimaterial simulations
Clearly this requires a MaterialDensity field to be present</a:documentation>
            <attribute name="name">
              <value>MaterialDensity</value>
            </attribute>
          </element>
          <element name="density">
            <a:documentation>Select density to use in the Reduced Conservation of Mass Equation
Use the bulk Density
Clearly this requires a Density field to be present</a:documentation>
            <attribute name="name">
              <value>Density</value>
            </attribute>
          </element>
          <element name="density">
            <a:documentation>Select density to use in the Reduced Conservation of Mass Equation</a:documentation>
            <attribute name="name">
              <data type="string" datatypeLibrary=""/>
            </attribute>
          </element>
        </choice>
      </element>
      <element name="equation">
        <a:documentation>***UNDER TESTING***
Select the equation used to solve for this field.
Internal Energy equation - requires the selection of a Density field.
ONLY WORKS FOR CONTROL VOLUME DISCRETISATIONS WITHOUT A
DIFFUSIVITY, SOURCE OR ABSORPTION.
Solve the internal energy equation for this field.
Requires pressure and velocity fields to be present.
Uses a nonconservative time discretisation.</a:documentation>
        <attribute name="name">
          <value>InternalEnergy</value>
        </attribute>
        <choice>
          <element name="density">
            <a:documentation>Select density to use in the Internal Energy Equation
Use the MaterialDensity - useful for multimaterial simulations
Clearly this requires a MaterialDensity field to be present
Whatever field is selected must be present.</a:documentation>
            <attribute name="name">
              <value>MaterialDensity</value>
            </attribute>
          </element>
          <element name="density">
            <a:documentation>Select density to use in the Internal Energy Equation
Use the bulk Density
Clearly this requires a Density field to be present
Whatever field is selected must be present.</a:documentation>
            <attribute name="name">
              <value>Density</value>
            </attribute>
          </element>
          <element name="density">
            <a:documentation>Select density to use in the Internal Energy Equation
Whatever field is selected must be present.</a:documentation>
            <attribute name="name">
              <data type="string" datatypeLibrary=""/>
            </attribute>
          </element>
        </choice>
      </element>
    </choice>
    <element name="spatial_discretisation">
      <a:documentation>Spatial discretisation options</a:documentation>
      <choice>
        <element name="continuous_galerkin">
          <a:documentation>Use a finite element discretisation - needs to be fleshed out</a:documentation>
          <attribute name="replaces">
            <value>DISOTT</value>
          </attribute>
          <choice>
            <element name="petrof_galerkin_xt">
              <a:documentation>Petrof Galerkin x-t.</a:documentation>
              <attribute name="replaces">
                <value>DISOTT = 1</value>
              </attribute>
              <empty/>
            </element>
            <element name="weighted_petrof_galerkin_xt">
              <a:documentation>Petrof Galerkin x-t(BUT weighted to get correct diffusion at steady state).</a:documentation>
              <attribute name="replaces">
                <value>DISOTT = 2</value>
              </attribute>
              <empty/>
            </element>
            <element name="petrof_galerkin_x">
              <a:documentation>Petrof Galerkin (x,y)</a:documentation>
              <attribute name="replaces">
                <value>DISOTT = 3</value>
              </attribute>
              <empty/>
            </element>
            <element name="least_squares_xt">
              <a:documentation>Least squares (x,y,t). (symmetric)</a:documentation>
              <attribute name="replaces">
                <value>DISOTT = 4</value>
              </attribute>
              <empty/>
            </element>
            <element name="least_squares_x">
              <a:documentation>Least squares (x,y).</a:documentation>
              <attribute name="replaces">
                <value>DISOTT = 5</value>
              </attribute>
              <empty/>
            </element>
            <element name="least_squares_xtheta">
              <a:documentation>Least squares THETA-method. (symmetric)</a:documentation>
              <attribute name="replaces">
                <value>DISOTT = 6</value>
              </attribute>
              <empty/>
            </element>
            <element name="galerkin_theta">
              <a:documentation>Galerkin THETA-method.(symmetric when MAKSYM=.true.)</a:documentation>
              <attribute name="replaces">
                <value>DISOTT = 7</value>
              </attribute>
              <empty/>
            </element>
            <element name="space_weighting">
              <a:documentation>Space weighting</a:documentation>
              <attribute name="replaces">
                <value>DISOTT = 8</value>
              </attribute>
              <empty/>
            </element>
          </choice>
          <optional>
            <element name="optimally_upwind">
              <attribute name="replaces">
                <value>DISOTT &lt; 0</value>
              </attribute>
              <empty/>
            </element>
          </optional>
          <optional>
            <element name="lump_mass_matrix">
              <a:documentation>Lump the mass matrix in the field advection equation</a:documentation>
              <attribute name="replaces">
                <value>TLUMP</value>
              </attribute>
              <empty/>
            </element>
          </optional>
        </element>
        <element name="discontinuous_galerkin">
          <a:documentation>Discontinuous galerkin formulation. This causes Advection_diffusion_DG 
to be called instead of hart3D. You can also use this
formulation with a continuous field in which case a simple
galerkin formulation will result. </a:documentation>
          <attribute name="replace">
            <value>70 &lt;= DISOTT &lt;= 90</value>
          </attribute>
          <element name="diffusion_scheme">
            <choice>
              <element name="bassi_rebay">
                <a:documentation>Classical scheme from Bassi and Rebay 
(JCP 131 267-179 1997)</a:documentation>
                <empty/>
              </element>
              <element name="arbitrary_upwind">
                <a:documentation>Scheme in which upwinding is applied in
alternating directions. Devised by C.Pain.</a:documentation>
                <empty/>
              </element>
            </choice>
          </element>
        </element>
        <ref name="spatial_control_volume_options"/>
        <element name="legacy_discretisation">
          <element name="legacy_disott">
            <a:documentation>Legacy discretisation option (DISOTT)

From advdif comments (other possibilities may exist):
==============================================================
DISOTT .LT. 0 then optimaly upwinded.
The following are absolute values of DISOTT(NOT SPHERICAL COORDS)...
DISOTT=1 - Petrof Galerkin x-t.
DISOTT=2 - Petrof Galerkin x-t(BUT weighted to get correct diffusion at steady state).
DISOTT=3 - Petrof Galerkin (x,y).
DISOTT=4 - Least squares (x,y,t). (symmetric)
DISOTT=5 - Least squares (x,y).
DISOTT=6 - Least squares THETA-method. (symmetric)
DISOTT=7 - Galerkin THETA-method.(symmetric when MAKSYM=.true.)
DISOTT=8 - Space weighting.
FOR SPHERICAL COORDS...
DISOTT=1 - balancing diffusion based on (x,y) space.
DISOTT=2 - Laxwendrof balancing diffusion.
DISOTT=3 - (x,y,t) -balancing diffusion.
DISOTT=4 - No balancing diffusion.
==============================================================</a:documentation>
            <attribute name="replaces">
              <value>DISOTT, DEFALT (DISOTT = 1), ADV (DISOTT = 4, DEFALT = TRUE), DIFF (DISSOTT = 7)</value>
            </attribute>
            <ref name="integer"/>
          </element>
          <optional>
            <element name="legacy_tlump">
              <a:documentation>Lump the mass matrix in the field advection equation</a:documentation>
              <attribute name="replaces">
                <value>TLUMP, DEFALT (TLUMP = FALSE)</value>
              </attribute>
              <empty/>
            </element>
          </optional>
          <optional>
            <element name="legacy_suftem">
              <a:documentation>have a surface integral for the field equations.
Manual suggests false</a:documentation>
              <attribute name="replaces">
                <value>SUFTEM</value>
              </attribute>
              <empty/>
            </element>
          </optional>
          <optional>
            <!-- Should be set to 0 if not activated. -->
            <element name="legacy_ndisot">
              <a:documentation>Legacy discretisation option for control volume advection of field (NDISOT)

Should be a 2-to-4-digit number

1st digit (optional) : 1 to improve efficiency of upwind value calculation

2nd&amp;3rd digits       : Number of nonlinear iterations over advection equation

4th digit            : Discretisation option (see below)

4th DIGIT Method for face-value est.   Time-stepping     Limiting
------------------------------------------------------------------
  =0      1st order in space          Theta=specified    UNIVERSAL
  =1      1st order in space          Theta=non-linear   UNIVERSAL
  =2      Trapazoidal rule in space   Theta=specified    UNIVERSAL
  =3      Trapazoidal rule in space   Theta=non-linear   UNIVERSAL
  =4      Finite elements in space    Theta=specified    UNIVERSAL
  =5      Finite elements in space    Theta=non-linear   UNIVERSAL
  =6      Finite elements in space    Theta=specified    NONE
  =7      Finite elements in space    Theta=non-linear   NONE
  =8      Finite elements in space    Theta=specified    DOWNWIND+
  =9      Finite elements in space    Theta=non-linear   DOWNWIND+</a:documentation>
              <attribute name="replaces">
                <value>NDISOT</value>
              </attribute>
              <ref name="integer"/>
            </element>
          </optional>
        </element>
      </choice>
      <element name="conservative_advection">
        <a:documentation>Conservative discretisation of field advection equation
TBETA=1. -- conservative (divergence form)
TBETA=0. -- non-conservative
0. &lt; TBETA &lt; 1.</a:documentation>
        <attribute name="replaces">
          <value>TBETA, DEFALT (TBETA = 0.0)</value>
        </attribute>
        <ref name="real"/>
      </element>
      <optional>
        <element name="inner_element">
          <a:documentation>Candy and Pain's subgridscale model.
At this stage this only works if you select continuous galerkin above.</a:documentation>
          <attribute name="replaces">
            <value>NSUBTLOC, NSUBNTLOC</value>
          </attribute>
        </element>
      </optional>
    </element>
    <element name="temporal_discretisation">
      <element name="theta">
        <a:documentation>Implicit/explicit control (TTHETA)
=0.  -- explicit
=0.5 -- Crank-Nicholson
=1.  -- implicit</a:documentation>
        <attribute name="replaces">
          <value>TTHETA, DEFALT (TTHETA = 0.5)</value>
        </attribute>
        <ref name="real"/>
      </element>
      <optional>
        <ref name="temporal_control_volume_options"/>
      </optional>
      <optional>
        <element name="explicit_advection">
          <a:documentation>Treat advection terms explicity and therefore make matrix symmetric</a:documentation>
          <attribute name="replaces">
            <value>TSYM, DEFALT (TSYM=FALSE), DIFF (TSYM=TRUE)</value>
          </attribute>
        </element>
      </optional>
    </element>
    <element name="solver">
      <a:documentation>Solver</a:documentation>
      <ref name="linear_solver_options"/>
      <optional>
        <element name="legacy">
          <a:documentation>Legacy solver options
If selected legacy solvers solcg and gmres will be used
to solve the linear equations, otherwise PETSc is used.</a:documentation>
          <element name="max_iterations_outer">
            <a:documentation>Maximum number of iterations for tracer field solution
DDM iterations if parallel
Manual suggests 700</a:documentation>
            <attribute name="replaces">
              <value>TNOIT1</value>
            </attribute>
            <ref name="integer"/>
          </element>
          <element name="max_iterations_inner">
            <a:documentation>Maximum number of iterations for tracer field solution
Internal iterations if parallel
Manual suggests 700</a:documentation>
            <attribute name="replaces">
              <value>TNOIT2</value>
            </attribute>
            <ref name="integer"/>
          </element>
          <element name="max_nonrestarted_iterations_outer">
            <a:documentation>Maximum number of non-restarted outer iterations
Manual suggests 10</a:documentation>
            <attribute name="replaces">
              <value>TMINT1</value>
            </attribute>
            <ref name="integer"/>
          </element>
          <element name="max_nonrestarted_iterations_inner">
            <a:documentation>Maximum number of non-restarted inner iterations
Manual suggests 10</a:documentation>
            <attribute name="replaces">
              <value>TMINT2</value>
            </attribute>
            <ref name="integer"/>
          </element>
          <element name="tolerance_outer">
            <a:documentation>Tolerance for outer iteration of tracer field solution
Manual suggests 1.E-10</a:documentation>
            <attribute name="replaces">
              <value>TEROR1</value>
            </attribute>
            <ref name="real"/>
          </element>
          <element name="tolerance_inner">
            <a:documentation>Tolerance for inner iteration of tracer field solution
Manual suggests 1.E-10</a:documentation>
            <attribute name="replaces">
              <value>TEROR2</value>
            </attribute>
            <ref name="real"/>
          </element>
          <element name="field_no_outer_iterations_ddm">
            <a:documentation>miss out outeriterations for DDM solution.
Manual suggests 0</a:documentation>
            <attribute name="replaces">
              <value>TMISOU</value>
            </attribute>
            <ref name="integer"/>
          </element>
        </element>
      </optional>
    </element>
    <oneOrMore>
      <choice>
        <element name="initial_condition">
          <a:documentation>Initial condition for WholeMesh
Only specify one condition if not using mesh regions.
Otherwise select other initial_condition option, specify region_ids
and distinct names.  Then add extra intial conditions for other regions.</a:documentation>
          <attribute name="name">
            <value>WholeMesh</value>
          </attribute>
          <ref name="input_choice_initial_condition_real"/>
        </element>
        <element name="initial_condition">
          <a:documentation>Multiple initial_conditions are allowed if specifying different values in different
regions of the mesh (defined by region_ids).  In this case each initial_condition
requires a distinct name for the options dictionary.</a:documentation>
          <attribute name="name">
            <data type="string" datatypeLibrary=""/>
          </attribute>
          <ref name="region_ids"/>
          <ref name="input_choice_initial_condition_real"/>
        </element>
      </choice>
    </oneOrMore>
    <zeroOrMore>
      <element name="boundary_conditions">
        <a:documentation>Boundary conditions</a:documentation>
        <attribute name="replaces">
          <value>boundary, TTPER1 TTPER2 TTPERI</value>
        </attribute>
        <attribute name="name">
          <data type="string" datatypeLibrary=""/>
        </attribute>
        <element name="surface_ids">
          <a:documentation>Surface id:</a:documentation>
          <ref name="integer_vector"/>
        </element>
        <choice>
          <a:documentation>Type</a:documentation>
          <element name="type">
            <attribute name="name">
              <value>dirichlet</value>
            </attribute>
            <ref name="input_choice_real"/>
          </element>
          <element name="type">
            <attribute name="name">
              <value>neumann</value>
            </attribute>
            <ref name="input_choice_real"/>
          </element>
          <element name="type">
            <attribute name="name">
              <value>robin</value>
            </attribute>
            <element name="order_zero_coefficient">
              <ref name="input_choice_real"/>
            </element>
            <element name="order_one_coefficient">
              <ref name="input_choice_real"/>
            </element>
          </element>
          <element name="type">
            <a:documentation>If integrating the domain boundaries this
boundary condition type allows you to specify
the value outside the mesh, which will be used
if the flux is incoming.</a:documentation>
            <attribute name="name">
              <value>controlvolume</value>
            </attribute>
            <ref name="input_choice_real"/>
          </element>
        </choice>
      </element>
    </zeroOrMore>
    <optional>
      <element name="tensor_field">
        <a:documentation>Diffusivity for field</a:documentation>
        <attribute name="name">
          <value>Diffusivity</value>
        </attribute>
        <attribute name="rank">
          <value>2</value>
        </attribute>
        <attribute name="replaces">
          <value>TMUXX TMUYY TMUZZ TMUYZ TMUXZ TMUXY TALLMU TCONMU</value>
        </attribute>
        <element name="prescribed">
          <ref name="prescribed_values_tensor_field"/>
        </element>
      </element>
    </optional>
    <optional>
      <element name="scalar_field">
        <a:documentation>source term</a:documentation>
        <attribute name="name">
          <value>Source</value>
        </attribute>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="replaces">
          <value>ZSOT</value>
        </attribute>
        <element name="prescribed">
          <ref name="prescribed_scalar_field_no_adapt"/>
        </element>
      </element>
    </optional>
    <optional>
      <element name="scalar_field">
        <a:documentation>Absorption term</a:documentation>
        <attribute name="name">
          <value>Absorption</value>
        </attribute>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="replaces">
          <value>TABSZE TABS TABSCO TABSOR</value>
        </attribute>
        <element name="prescribed">
          <ref name="prescribed_scalar_field_no_adapt"/>
        </element>
      </element>
    </optional>
    <optional>
      <element name="test_timestep_accuracy">
        <a:documentation>Adaptive timestepping option
Test accuracy of field and determines a new timestep
Only used in multiphase and must have adaptive timestepping activated.</a:documentation>
        <attribute name="replaces">
          <value>TEQADP = TRUE</value>
        </attribute>
        <empty/>
      </element>
    </optional>
    <ref name="prognostic_scalar_output_options"/>
    <ref name="prognostic_scalar_stat_options"/>
    <ref name="scalar_convergence_options"/>
    <ref name="adaptivity_options_scalar_field"/>
    <optional>
      <element name="priority">
        <a:documentation>Set the priority of this field
This determines the order in which scalar_fields are solved for:
 - higher numbers have the highest priority
 - lower numbers (including negative) have the lowest priority
 - default if not set is 0</a:documentation>
        <ref name="integer"/>
      </element>
    </optional>
  </define>
  <!--
    Default child of diagnostic scalar field
    Currently, this is empty, but in future this might include
    options that are general to all diagnostic scalar fields
  -->
  <define name="diagnostic_scalar_field">
    <ref name="diagnostic_output_options"/>
    <ref name="diagnostic_scalar_stat_options"/>
    <ref name="adaptivity_options_scalar_field"/>
  </define>
  <!--
    Default child of prescribed scalar field
    This is a choice of ways of inputing the prescribed field
  -->
  <define name="prescribed_scalar_field">
    <ref name="prescribed_scalar_field_no_adapt"/>
    <ref name="adaptivity_options_scalar_field"/>
  </define>
  <!--
    Default child of prescribed scalar field without adaptivity options
    This is a choice of ways of inputing the prescribed field
  -->
  <define name="prescribed_scalar_field_no_adapt">
    <ref name="prescribed_values_scalar_field"/>
    <ref name="prescribed_output_options"/>
    <ref name="prescribed_scalar_stat_options"/>
  </define>
  <define name="prescribed_values_scalar_field">
    <oneOrMore>
      <choice>
        <element name="value">
          <a:documentation>Value for WholeMesh
Only specify one value if not using mesh regions.
Otherwise select other value option, specify region_ids
and distinct names.  Then add extra values for other regions.</a:documentation>
          <attribute name="name">
            <value>WholeMesh</value>
          </attribute>
          <ref name="input_choice_real"/>
        </element>
        <element name="value">
          <a:documentation>Multiple values are now allowed if using different value assignments
in different regions of the mesh (specified by region_ids).
In this case each value requires a distinct name for the options dictionary.</a:documentation>
          <attribute name="name">
            <data type="string" datatypeLibrary=""/>
          </attribute>
          <ref name="region_ids"/>
          <ref name="input_choice_real"/>
        </element>
      </choice>
    </oneOrMore>
  </define>
  <!--
    Default child of diagnostic vector field
    Currently, this is empty, but in future this might include
    options that are general to all diagnostic vector fields
  -->
  <define name="diagnostic_vector_field">
    <ref name="diagnostic_output_options"/>
    <ref name="diagnostic_vector_stat_options"/>
    <ref name="adaptivity_options_vector_field"/>
  </define>
  <!--
    Default child of prescribed vector field
    This is a choice of ways of inputing the prescribed field
  -->
  <define name="prescribed_vector_field">
    <ref name="prescribed_vector_field_no_adapt"/>
    <ref name="adaptivity_options_vector_field"/>
  </define>
  <!--
    Default child of prescribed vector field without adaptivity options
    This is a choice of ways of inputing the prescribed field
  -->
  <define name="prescribed_vector_field_no_adapt">
    <ref name="prescribed_values_vector_field"/>
    <ref name="prescribed_output_options"/>
    <ref name="prescribed_vector_stat_options"/>
  </define>
  <define name="prescribed_values_vector_field">
    <oneOrMore>
      <choice>
        <element name="value">
          <a:documentation>Value for WholeMesh
Only specify one value if not using mesh regions.
Otherwise select other value option, specify region_ids
and distinct names.  Then add extra values for other regions.</a:documentation>
          <attribute name="name">
            <value>WholeMesh</value>
          </attribute>
          <ref name="input_choice_real_dim_vector"/>
        </element>
        <element name="value">
          <a:documentation>Multiple values are now allowed if using different value assignments
in different regions of the mesh (specified by region_ids).
In this case each value requires a distinct name for the options dictionary.</a:documentation>
          <attribute name="name">
            <data type="string" datatypeLibrary=""/>
          </attribute>
          <ref name="region_ids"/>
          <ref name="input_choice_real_dim_vector"/>
        </element>
      </choice>
    </oneOrMore>
  </define>
  <!--
    Default child of diagnostic tensor field
    Currently, this is empty, but in future this might include
    options that are general to all diagnostic tensor fields
  -->
  <define name="diagnostic_tensor_field">
    <ref name="diagnostic_output_options"/>
    <ref name="adaptivity_options_tensor_field"/>
  </define>
  <!--
    Default child of prescribed vector field
    This is a choice of ways of inputing the prescribed tensor field
    If the field is constant then a symmetric, or asymmetric tensor may be entered
  -->
  <define name="prescribed_tensor_field">
    <ref name="prescribed_values_tensor_field"/>
    <ref name="adaptivity_options_tensor_field"/>
  </define>
  <define name="prescribed_values_tensor_field">
    <oneOrMore>
      <choice>
        <element name="value">
          <a:documentation>Value for WholeMesh
Only specify one value if not using mesh regions.
Otherwise select other value option, specify region_ids
and distinct names.  Then add extra values for other regions.</a:documentation>
          <attribute name="name">
            <value>WholeMesh</value>
          </attribute>
          <ref name="input_choice_tensor_field"/>
        </element>
        <element name="value">
          <a:documentation>Multiple values are now allowed if using different value assignments
in different regions of the mesh (specified by region_ids).
In this case each value requires a distinct name for the options dictionary.</a:documentation>
          <attribute name="name">
            <data type="string" datatypeLibrary=""/>
          </attribute>
          <ref name="region_ids"/>
          <ref name="input_choice_tensor_field"/>
        </element>
      </choice>
    </oneOrMore>
  </define>
  <define name="prognostic_pressure_field">
    <element name="spatial_discretisation">
      <choice>
        <element name="continuous_galerkin">
          <optional>
            <element name="remove_stabilisation_term">
              <a:documentation>remove the  fourth order pressure stabilisation term KCMC
must be removed for multimaterial calculations</a:documentation>
              <attribute name="replaces">
                <value>NOFILT</value>
              </attribute>
            </element>
          </optional>
        </element>
        <element name="control_volumes">
          <attribute name="replaces">
            <value>NCOLOP = X1XXXXX -&gt; INTERF, NOFILT</value>
          </attribute>
          <optional>
            <element name="integrate_domain_boundaries">
              <attribute name="replaces">
                <value>CVSURF from solidity_options.inp</value>
              </attribute>
              <empty/>
            </element>
          </optional>
        </element>
      </choice>
    </element>
    <optional>
      <element name="reference_node">
        <a:documentation>Reference node (Node at which pressure = 0.)
=0  -- unset</a:documentation>
        <attribute name="replaces">
          <value>NDPSET</value>
        </attribute>
        <ref name="integer"/>
      </element>
    </optional>
    <optional>
      <element name="atmospheric_pressure">
        <a:documentation>Atmospheric pressure
Manual suggests 1.01325E+6</a:documentation>
        <attribute name="replaces">
          <value>PATMOS</value>
        </attribute>
        <ref name="real"/>
      </element>
    </optional>
    <optional>
      <element name="hydrostatic_pressure_solver">
        <a:documentation>Switch on the use of the hydrostatic pressure solver.</a:documentation>
        <attribute name="replaces">
          <value>HYDROS</value>
        </attribute>
        <empty/>
      </element>
    </optional>
    <optional>
      <element name="legacy_discretisation">
        <a:documentation>discretization</a:documentation>
        <optional>
          <element name="integrate_continuity_greens">
            <a:documentation>Option for whether or not to integrate continuity eqn using Green's.
If present use Green's theorem.
Manual suggests not present.</a:documentation>
            <attribute name="replaces">
              <value>PREOPT</value>
            </attribute>
            <empty/>
          </element>
        </optional>
        <optional>
          <element name="symmetric_pressure">
            <a:documentation>Option to only use symmetric pressure matrix</a:documentation>
            <attribute name="replaces">
              <value>PRESYM</value>
            </attribute>
            <empty/>
          </element>
        </optional>
        <optional>
          <element name="use_momentum_diagonal">
            <a:documentation>Option to use the diagonal of the left hand side momentum equation
in the construction of the pressure matrix CMC.
Must be used with seredipity elements.</a:documentation>
            <attribute name="replaces">
              <value>MLCENT</value>
            </attribute>
            <empty/>
          </element>
        </optional>
      </element>
    </optional>
    <element name="scheme">
      <a:documentation>scheme</a:documentation>
      <element name="poisson_pressure_solution">
        <a:documentation>Use a poisson pressure equation to calculate a first guess at pressure.
This does not necessarily satisfy continuity.
= 1 -- use a poisson guess at every timestep
= 0 -- never use a poisson guess
=-1 -- use a poisson guess at the first timestep only
Manual suggests -1</a:documentation>
        <attribute name="replaces">
          <value>POISON</value>
        </attribute>
        <group>
          <element name="string_value">
            <!--
              Lines is a hint to the gui about the size of the text box.
              It is not an enforced limit on string length.
            -->
            <attribute name="lines">
              <value>1</value>
            </attribute>
            <choice>
              <value>never</value>
              <value>every timestep</value>
              <value>only first timestep</value>
            </choice>
          </element>
          <ref name="comment"/>
        </group>
      </element>
      <optional>
        <element name="use_projection_method">
          <a:documentation>use the projection method to determine the pressure and satisfy continuity
=0 -- off
=1 -- on
Manual suggests 1</a:documentation>
          <attribute name="replaces">
            <value>PROJEC</value>
          </attribute>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="update_discretised_equation">
          <a:documentation>rediscretise the equations at every timestep and iteration
(for instance if using a compressible formulation
or if density varies a lot or if not using a Boussinesque approximation)</a:documentation>
          <attribute name="replaces">
            <value>CMCHAN</value>
          </attribute>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="multimaterial_compressibility">
          <a:documentation>Options used with the multimaterial compressibility method
***UNDER CONSTRUCTION***</a:documentation>
          <optional>
            <choice>
              <element name="density_normalisation">
                <a:documentation>Density used to normalise each materials contribution
to the C_P^T matrix.  Leave unselected for no normalisation.</a:documentation>
                <attribute name="name">
                  <value>MaterialDensity</value>
                </attribute>
                <empty/>
              </element>
              <element name="density_normalisation">
                <a:documentation>Density used to normalise each materials contribution
to the C_P^T matrix.  Leave unselected for no normalisation.</a:documentation>
                <attribute name="name">
                  <value>Density</value>
                </attribute>
                <empty/>
              </element>
              <element name="density_normalisation">
                <a:documentation>Density used to normalise each materials contribution
to the C_P^T matrix.  Leave unselected for no normalisation.</a:documentation>
                <attribute name="name">
                  <data type="string" datatypeLibrary=""/>
                </attribute>
                <empty/>
              </element>
            </choice>
          </optional>
        </element>
      </optional>
    </element>
    <element name="solver">
      <a:documentation>Solver</a:documentation>
      <ref name="linear_solver_options"/>
      <optional>
        <element name="legacy">
          <a:documentation>Legacy solver options
If selected legacy solvers solcg and gmres will be used
to solve the linear equations, otherwise PETSc is used.</a:documentation>
          <element name="mass_matrix">
            <a:documentation>Mass matrix (multiphase TBD)</a:documentation>
            <element name="max_iterations">
              <a:documentation>Maximum number of iterations for mass matrix
Manual suggests 100</a:documentation>
              <attribute name="replaces">
                <value>MASNOI</value>
              </attribute>
              <ref name="integer"/>
            </element>
            <element name="preconditioner">
              <a:documentation>This defines the preconditioner for the mass matrix (TBD)
Manual suggests 1</a:documentation>
              <attribute name="replaces">
                <value>MASPRE</value>
              </attribute>
              <ref name="integer"/>
            </element>
            <element name="tolerance">
              <a:documentation>Tolerance for solution of the mass matrix
Manual suggests 1.E-10</a:documentation>
              <attribute name="replaces">
                <value>MASERR</value>
              </attribute>
              <ref name="real"/>
            </element>
            <element name="ssor_preconditioning_mass_relaxation">
              <a:documentation>relaxation parameter for SSOR preconditioning of mass matrix.
Manual suggests 1.0</a:documentation>
              <attribute name="replaces">
                <value>MASW</value>
              </attribute>
              <ref name="real"/>
            </element>
            <optional>
              <element name="symmetric_mass_matrix">
                <a:documentation>use symmetry to store mass matrix.
Manual suggests false</a:documentation>
                <attribute name="replaces">
                  <value>MASSYM</value>
                </attribute>
                <empty/>
              </element>
            </optional>
          </element>
          <element name="pressure_matrix">
            <a:documentation>Pressure solution</a:documentation>
            <element name="max_iterations_outer">
              <a:documentation>Maximum number of iterations for pressure solution
Inner iterations if UZAWA, or consistent mass method.
DDM iterations if parallel
Manual suggests 700</a:documentation>
              <attribute name="replaces">
                <value>PRENOI</value>
              </attribute>
              <ref name="integer"/>
            </element>
            <element name="max_iterations_inner">
              <a:documentation>Maximum number of iterations for pressure matrix
Internal iterations if parallel
Manual suggests 700</a:documentation>
              <attribute name="replaces">
                <value>PINNOI</value>
              </attribute>
              <ref name="integer"/>
            </element>
            <element name="tolerance_outer">
              <a:documentation>Tolerance for outer iteration of the pressure solution
Manual suggests 1.E-10</a:documentation>
              <attribute name="replaces">
                <value>PREERR</value>
              </attribute>
              <ref name="real"/>
            </element>
            <element name="tolerance_inner">
              <a:documentation>Tolerance for inner iteration of the pressure solution
Manual suggests 1.E-10</a:documentation>
              <attribute name="replaces">
                <value>PINERR</value>
              </attribute>
              <ref name="real"/>
            </element>
            <element name="preconditioner">
              <a:documentation>preconditioner for pressure matrix.
Manual suggests 1</a:documentation>
              <attribute name="replaces">
                <value>PREPRE</value>
              </attribute>
              <ref name="integer"/>
            </element>
          </element>
        </element>
      </optional>
    </element>
    <zeroOrMore>
      <choice>
        <element name="initial_condition">
          <a:documentation>Initial condition for WholeMesh
Only specify one condition if not using mesh regions.
Otherwise select other initial_condition option, specify region_ids
and distinct names.  Then add extra intial conditions for other regions.</a:documentation>
          <attribute name="name">
            <value>WholeMesh</value>
          </attribute>
          <ref name="input_choice_initial_condition_real"/>
        </element>
        <element name="initial_condition">
          <a:documentation>Multiple initial_conditions are allowed if specifying different values in different
regions of the mesh (defined by region_ids).  In this case each initial_condition
requires a distinct name for the options dictionary.</a:documentation>
          <attribute name="name">
            <data type="string" datatypeLibrary=""/>
          </attribute>
          <ref name="region_ids"/>
          <ref name="input_choice_initial_condition_real"/>
        </element>
      </choice>
    </zeroOrMore>
    <ref name="prognostic_scalar_output_options"/>
    <ref name="prognostic_scalar_stat_options"/>
    <ref name="scalar_convergence_options"/>
    <ref name="adaptivity_options_scalar_field"/>
    <optional>
      <element name="multiphase">
        <optional>
          <choice>
            <element name="interface_pressure_legacy_pinmod_1">
              <a:documentation>if off replaces MPHAOP(1,1)=0
IVP*((1+6*RGAS*RLIQ)*RGAS*RLIQ*(RGAS*DENGAS+RLIQ*DENLIQ))</a:documentation>
              <attribute name="replaces">
                <value>MPHAOP(1,1)=1</value>
              </attribute>
            </element>
            <element name="interface_pressure_legacy_pinmod_2">
              <a:documentation>if off replaces MPHAOP(1,1)=0
IVP*(RGAS*RLIQ*(RGAS*DENGAS+RLIQ*DENLIQ -drag coeff).</a:documentation>
              <attribute name="replaces">
                <value>MPHAOP(1,1)=2</value>
              </attribute>
            </element>
            <element name="interface_pressure_legacy_pinmod_3">
              <a:documentation>if off replaces MPHAOP(1,1)=0
IVP*(DENLIQ*RGAS -solid particle).</a:documentation>
              <attribute name="replaces">
                <value>MPHAOP(1,1)=3</value>
              </attribute>
            </element>
            <element name="interface_pressure_seperated_flows">
              <a:documentation>if off replaces MPHAOP(1,1)=0
for seperated flows see Benerge notes page 11.</a:documentation>
              <attribute name="replaces">
                <value>MPHAOP(1,1)=4</value>
              </attribute>
            </element>
            <element name="interface_pressure_conservative_seperated_flows">
              <a:documentation>if off replaces MPHAOP(1,1)=0
conservative form of 4 i.e. coefficent RGAS*RLIQ.</a:documentation>
              <attribute name="replaces">
                <value>MPHAOP(1,1)=5</value>
              </attribute>
            </element>
            <element name="interface_pressure_legacy_pinmod_6">
              <a:documentation>if off replaces MPHAOP(1,1)=0
RGAS*RLIQ*DENGAS*DENLIQ/(RGAS*DENLIQ+RLIQ*DENGAS) (CATHARE option)</a:documentation>
              <attribute name="replaces">
                <value>MPHAOP(1,1)=6</value>
              </attribute>
            </element>
            <element name="interface_pressure_hyperbolic">
              <a:documentation>if off replaces MPHAOP(1,1)=0
DENLIQ*RGAS - makes system hyperbolic.</a:documentation>
              <attribute name="replaces">
                <value>MPHAOP(1,1)=7</value>
              </attribute>
            </element>
            <element name="interface_pressure_solid_particle">
              <a:documentation>if off replaces MPHAOP(1,1)=0
IVP*(DENLIQ -solid particle).</a:documentation>
              <attribute name="replaces">
                <value>MPHAOP(1,1)=8</value>
              </attribute>
            </element>
            <element name="interface_pressure_legacy_pinmod_negative">
              <a:documentation>if off replaces MPHAOP(1,1)=0
don't add contibution into gas or 2'nd phase</a:documentation>
              <attribute name="replaces">
                <value>MPHAOP(1,1)&lt;0</value>
              </attribute>
              <ref name="integer"/>
            </element>
          </choice>
        </optional>
        <optional>
          <element name="add_pressure">
            <attribute name="replaces">
              <value>MPHAOP(1,2)</value>
            </attribute>
          </element>
        </optional>
        <optional>
          <choice>
            <element name="fluidised_bed_model_b">
              <attribute name="replaces">
                <value>FBMODL = 2</value>
              </attribute>
            </element>
            <element name="fluidised_bed_no_ke_transport">
              <attribute name="replaces">
                <value>FBMODL = -11</value>
              </attribute>
            </element>
            <element name="fluidised_bed_ke_include_drag">
              <attribute name="replaces">
                <value>FBMODL = -1</value>
              </attribute>
            </element>
          </choice>
        </optional>
      </element>
    </optional>
  </define>
  <!--
    Balance pressure field, this is a copy of prognostic_scalar_field above
    removing all options that don't apply (mainly advection related)
  -->
  <define name="prognostic_balance_pressure_field">
    <element name="spatial_discretisation">
      <a:documentation>Spatial discretisation options</a:documentation>
      <group>
        <!--
          note I removed disott here as it
          will switch on free-surface options in geoeli1p
          should be hard-coded to 0 in comsca therefore
          tlump is irrelevant
          suftem should be hard-coded to .false. if nlevel is set
        -->
        <element name="geostrophic_pressure_option">
          <a:documentation>Geostrophic pressure option
If you use the hydros option for the pressure field
you should exclude buoyancy here.</a:documentation>
          <attribute name="replaces">
            <value>GEOBAL</value>
          </attribute>
          <element name="string_value">
            <choice>
              <value>include_buoyancy</value>
              <value>exclude_buoyancy</value>
            </choice>
          </element>
        </element>
        <optional>
          <element name="legacy_discretisation">
            <optional>
              <element name="legacy_nlevel">
                <a:documentation>For layered meshes enter the number of (nodal) levels.
This is a legacy option that will not be needed anymore
in the near future.</a:documentation>
                <attribute name="replaces">
                  <value>PREPRE</value>
                </attribute>
                <ref name="integer"/>
              </element>
            </optional>
          </element>
        </optional>
      </group>
      <!--
        unfortunately tbeta doesn't make sense here
        so we have to code an exception for not having it in comsca
      -->
    </element>
    <!--
      Temporal_discretisation doesn't apply to balance pressure
      (there's no time derivative). Exception again
      Solver block is the same as prognostic_scalar_field
    -->
    <element name="solver">
      <a:documentation>Solver</a:documentation>
      <ref name="linear_solver_options"/>
      <optional>
        <element name="legacy">
          <a:documentation>Legacy solver options
If selected legacy solvers solcg and gmres will be used
to solve the linear equations, otherwise PETSc is used.</a:documentation>
          <!-- need extra layer for consistency with pressure field -->
          <element name="pressure_matrix">
            <a:documentation>Pressure solution</a:documentation>
            <element name="max_iterations_outer">
              <a:documentation>Maximum number of iterations for pressure solution
Inner iterations if UZAWA, or consistent mass method.
DDM iterations if parallel
Manual suggests 700</a:documentation>
              <attribute name="replaces">
                <value>PRENOI</value>
              </attribute>
              <ref name="integer"/>
            </element>
            <element name="max_iterations_inner">
              <a:documentation>Maximum number of iterations for pressure matrix
Internal iterations if parallel
Manual suggests 700</a:documentation>
              <attribute name="replaces">
                <value>PINNOI</value>
              </attribute>
              <ref name="integer"/>
            </element>
            <element name="tolerance_outer">
              <a:documentation>Tolerance for outer iteration of the pressure solution
Manual suggests 1.E-10</a:documentation>
              <attribute name="replaces">
                <value>PREERR</value>
              </attribute>
              <ref name="real"/>
            </element>
            <element name="tolerance_inner">
              <a:documentation>Tolerance for inner iteration of the pressure solution
Manual suggests 1.E-10</a:documentation>
              <attribute name="replaces">
                <value>PINERR</value>
              </attribute>
              <ref name="real"/>
            </element>
            <element name="preconditioner">
              <a:documentation>preconditioner for pressure matrix.
Manual suggests 1</a:documentation>
              <attribute name="replaces">
                <value>PREPRE</value>
              </attribute>
              <ref name="integer"/>
            </element>
          </element>
        </element>
      </optional>
    </element>
    <!--
      Alas, no initial_condition either...
      There are boundary conditions, but nothing you can set
      (all derived from velocity b.c.'s)
      no Diffusivity tensor_field
      no Source scalar_field
      no Absorption scalar_field
      no adaptive time-stepping
    -->
    <ref name="prognostic_scalar_output_options"/>
    <ref name="prognostic_scalar_stat_options"/>
    <ref name="scalar_convergence_options"/>
    <ref name="adaptivity_options_scalar_field"/>
  </define>
  <!--
    free surface field, this is a copy of prognostic_scalar_field above
    removing all options that don't apply (mainly advection related)
  -->
  <define name="prognostic_free_surface_field">
    <element name="spatial_discretisation">
      <a:documentation>Spatial discretisation options</a:documentation>
      <optional>
        <element name="free_surface_3D">
          <a:documentation>Form a full 3D system for the free surface</a:documentation>
          <attribute name="replaces">
            <value>DISOTT=2^0 (frees3d)</value>
          </attribute>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="fourth_order_dissipation">
          <attribute name="replaces">
            <value>DISOTT=2^2 (fourthfrees_diss)</value>
          </attribute>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="low_order_free_surface">
          <a:documentation>low order (linear) free surface</a:documentation>
          <attribute name="replaces">
            <value>DISOTT=2^3 (geo_short)</value>
          </attribute>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="tidal_components">
          <a:documentation>Switch on tidal components</a:documentation>
          <attribute name="replaces">
            <value>DISOTT=2^5 (tidallcom)</value>
          </attribute>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="love_number">
          <a:documentation>Switches on a Love number of 0.3</a:documentation>
          <attribute name="replaces">
            <value>DISOTT=2^6 (tlove)</value>
          </attribute>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="static_tidal_force">
          <a:documentation>Use static tidal force for testing</a:documentation>
          <attribute name="replaces">
            <value>DISOTT=2^7 (statid)</value>
          </attribute>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="switch_off_free_surface_filtering">
          <a:documentation>Switches off stabilisation filter for free surface</a:documentation>
          <attribute name="replaces">
            <value>DISOTT=2^9 (nofsta)</value>
          </attribute>
          <empty/>
        </element>
      </optional>
      <optional>
        <!-- !!! should this go to balance pressure ???? -->
        <element name="switch_off_balance_pressure_filtering">
          <a:documentation>Switches off stabilisation filter for balance pressure</a:documentation>
          <attribute name="replaces">
            <value>DISOTT=2^9 (nofilt)</value>
          </attribute>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="wetting_drying">
          <a:documentation>Apply wetting and drying routines</a:documentation>
          <attribute name="replaces">
            <value>DISOTT=2^10 (wetdry)</value>
          </attribute>
          <empty/>
        </element>
      </optional>
    </element>
    <!--
      atheta, ctheta and fstheta (absorption, coriolis and free surface)
      need to go in temporal discretisation
      they are currently hard-coded however
    -->
    <element name="temporal_discretisation">
      <element name="theta">
        <a:documentation>Implicit/explicitness for the free surface.
Suggested value 1.0 (should be at least bigger than 0.5).
=0.  -- explicit
=0.5 -- Crank-Nicholson
=1.  -- implicit</a:documentation>
        <attribute name="replaces">
          <value>THETA</value>
        </attribute>
        <ref name="real"/>
      </element>
      <optional>
        <!-- Maybe this should go under a proper absorption field under free surface? -->
        <element name="absorption_theta">
          <a:documentation>Implicit/explicitness for absorption
=0.  -- explicit (default)
=0.5 -- Crank-Nicholson
=1.  -- implicit</a:documentation>
          <attribute name="replaces">
            <value>disott=2^4 (IMPABS)</value>
          </attribute>
          <ref name="real"/>
        </element>
      </optional>
    </element>
    <element name="solver">
      <a:documentation>Solver</a:documentation>
      <ref name="linear_solver_options"/>
      <optional>
        <element name="legacy">
          <a:documentation>Legacy solver options
If selected legacy solvers solcg and gmres will be used
to solve the linear equations, otherwise PETSc is used.</a:documentation>
          <!-- need extra layer for consistency with pressure field -->
          <element name="pressure_matrix">
            <a:documentation>Pressure solution</a:documentation>
            <element name="max_iterations_outer">
              <a:documentation>Maximum number of iterations for pressure solution
Inner iterations if UZAWA, or consistent mass method.
DDM iterations if parallel
Manual suggests 700</a:documentation>
              <attribute name="replaces">
                <value>PRENOI</value>
              </attribute>
              <ref name="integer"/>
            </element>
            <element name="max_iterations_inner">
              <a:documentation>Maximum number of iterations for pressure matrix
Internal iterations if parallel
Manual suggests 700</a:documentation>
              <attribute name="replaces">
                <value>PINNOI</value>
              </attribute>
              <ref name="integer"/>
            </element>
            <element name="tolerance_outer">
              <a:documentation>Tolerance for outer iteration of the pressure solution
Manual suggests 1.E-10</a:documentation>
              <attribute name="replaces">
                <value>PREERR</value>
              </attribute>
              <ref name="real"/>
            </element>
            <element name="tolerance_inner">
              <a:documentation>Tolerance for inner iteration of the pressure solution
Manual suggests 1.E-10</a:documentation>
              <attribute name="replaces">
                <value>PINERR</value>
              </attribute>
              <ref name="real"/>
            </element>
            <element name="preconditioner">
              <a:documentation>preconditioner for pressure matrix.
Manual suggests 1</a:documentation>
              <attribute name="replaces">
                <value>PREPRE</value>
              </attribute>
              <ref name="integer"/>
            </element>
          </element>
        </element>
      </optional>
    </element>
    <oneOrMore>
      <choice>
        <element name="initial_condition">
          <a:documentation>Initial condition for WholeMesh
Only specify one condition if not using mesh regions.
Otherwise select other initial_condition option, specify region_ids
and distinct names.  Then add extra intial conditions for other regions.</a:documentation>
          <attribute name="name">
            <value>WholeMesh</value>
          </attribute>
          <ref name="input_choice_initial_condition_real"/>
        </element>
        <element name="initial_condition">
          <a:documentation>Multiple initial_conditions are allowed if specifying different values in different
regions of the mesh (defined by region_ids).  In this case each initial_condition
requires a distinct name for the options dictionary.</a:documentation>
          <attribute name="name">
            <data type="string" datatypeLibrary=""/>
          </attribute>
          <ref name="region_ids"/>
          <ref name="input_choice_initial_condition_real"/>
        </element>
      </choice>
    </oneOrMore>
    <zeroOrMore>
      <element name="boundary_conditions">
        <a:documentation>Boundary conditions</a:documentation>
        <attribute name="replaces">
          <value>boundary, TTPER1 TTPER2 TTPERI</value>
        </attribute>
        <attribute name="name">
          <data type="string" datatypeLibrary=""/>
        </attribute>
        <element name="surface_ids">
          <a:documentation>Surface id:</a:documentation>
          <ref name="integer_vector"/>
        </element>
        <choice>
          <a:documentation>Type</a:documentation>
          <element name="type">
            <attribute name="name">
              <value>dirichlet</value>
            </attribute>
            <ref name="input_choice_real"/>
          </element>
          <element name="type">
            <attribute name="name">
              <value>neumann</value>
            </attribute>
            <ref name="input_choice_real"/>
          </element>
          <element name="type">
            <attribute name="name">
              <value>robin</value>
            </attribute>
            <element name="order_zero_coefficient">
              <ref name="input_choice_real"/>
            </element>
            <element name="order_one_coefficient">
              <ref name="input_choice_real"/>
            </element>
          </element>
        </choice>
      </element>
    </zeroOrMore>
    <!--
      no Diffusivity for field
      no source term
      no Absorption term
      no Adaptive timestepping option
    -->
    <ref name="prognostic_scalar_output_options"/>
    <ref name="prognostic_scalar_stat_options"/>
    <ref name="scalar_convergence_options"/>
    <ref name="adaptivity_options_scalar_field"/>
  </define>
  <define name="prognostic_mellor_yamada_field">
    <element name="equation">
      <attribute name="name">
        <value>AdvectionDiffusion</value>
      </attribute>
    </element>
    <element name="spatial_discretisation">
      <a:documentation>Spatial discretisation options</a:documentation>
      <choice>
        <element name="continuous_galerkin">
          <a:documentation>Use a finite element discretisation - needs to be fleshed out</a:documentation>
          <attribute name="replaces">
            <value>DISOTT</value>
          </attribute>
          <choice>
            <element name="petrof_galerkin_xt">
              <a:documentation>Petrof Galerkin x-t.</a:documentation>
              <attribute name="replaces">
                <value>DISOTT = 1</value>
              </attribute>
              <empty/>
            </element>
            <element name="weighted_petrof_galerkin_xt">
              <a:documentation>Petrof Galerkin x-t(BUT weighted to get correct diffusion at steady state).</a:documentation>
              <attribute name="replaces">
                <value>DISOTT = 2</value>
              </attribute>
              <empty/>
            </element>
            <element name="petrof_galerkin_x">
              <a:documentation>Petrof Galerkin (x,y)</a:documentation>
              <attribute name="replaces">
                <value>DISOTT = 3</value>
              </attribute>
              <empty/>
            </element>
            <element name="least_squares_xt">
              <a:documentation>Least squares (x,y,t). (symmetric)</a:documentation>
              <attribute name="replaces">
                <value>DISOTT = 4</value>
              </attribute>
              <empty/>
            </element>
            <element name="least_squares_x">
              <a:documentation>Least squares (x,y).</a:documentation>
              <attribute name="replaces">
                <value>DISOTT = 5</value>
              </attribute>
              <empty/>
            </element>
            <element name="least_squares_xtheta">
              <a:documentation>Least squares THETA-method. (symmetric)</a:documentation>
              <attribute name="replaces">
                <value>DISOTT = 6</value>
              </attribute>
              <empty/>
            </element>
            <element name="galerkin_theta">
              <a:documentation>Galerkin THETA-method.(symmetric when MAKSYM=.true.)</a:documentation>
              <attribute name="replaces">
                <value>DISOTT = 7</value>
              </attribute>
              <empty/>
            </element>
            <element name="space_weighting">
              <a:documentation>Space weighting</a:documentation>
              <attribute name="replaces">
                <value>DISOTT = 8</value>
              </attribute>
              <empty/>
            </element>
          </choice>
          <optional>
            <element name="optimally_upwind">
              <attribute name="replaces">
                <value>DISOTT &lt; 0</value>
              </attribute>
              <empty/>
            </element>
          </optional>
          <optional>
            <element name="lump_mass_matrix">
              <a:documentation>Lump the mass matrix in the field advection equation</a:documentation>
              <attribute name="replaces">
                <value>TLUMP</value>
              </attribute>
              <empty/>
            </element>
          </optional>
        </element>
        <element name="discontinuous_galerkin">
          <a:documentation>A possible location for the discrete galerkin stuff - needs to be fleshed out</a:documentation>
          <attribute name="replace">
            <value>70 &lt;= DISOTT &lt;= 90</value>
          </attribute>
        </element>
        <ref name="spatial_control_volume_options"/>
        <element name="legacy_discretisation">
          <element name="legacy_disott">
            <a:documentation>Legacy discretisation option (DISOTT)

From advdif comments (other possibilities may exist):
==============================================================
DISOTT .LT. 0 then optimaly upwinded.
The following are absolute values of DISOTT(NOT SPHERICAL COORDS)...
DISOTT=1 - Petrof Galerkin x-t.
DISOTT=2 - Petrof Galerkin x-t(BUT weighted to get correct diffusion at steady state).
DISOTT=3 - Petrof Galerkin (x,y).
DISOTT=4 - Least squares (x,y,t). (symmetric)
DISOTT=5 - Least squares (x,y).
DISOTT=6 - Least squares THETA-method. (symmetric)
DISOTT=7 - Galerkin THETA-method.(symmetric when MAKSYM=.true.)
DISOTT=8 - Space weighting.
FOR SPHERICAL COORDS...
DISOTT=1 - balancing diffusion based on (x,y) space.
DISOTT=2 - Laxwendrof balancing diffusion.
DISOTT=3 - (x,y,t) -balancing diffusion.
DISOTT=4 - No balancing diffusion.
==============================================================</a:documentation>
            <attribute name="replaces">
              <value>DISOTT, DEFALT (DISOTT = 1), ADV (DISOTT = 4, DEFALT = TRUE), DIFF (DISSOTT = 7)</value>
            </attribute>
            <ref name="integer"/>
          </element>
          <optional>
            <element name="legacy_tlump">
              <a:documentation>Lump the mass matrix in the field advection equation</a:documentation>
              <attribute name="replaces">
                <value>TLUMP, DEFALT (TLUMP = FALSE)</value>
              </attribute>
              <empty/>
            </element>
          </optional>
          <optional>
            <!-- Should be set to 0 if not activated. -->
            <element name="legacy_ndisot">
              <a:documentation>Legacy discretisation option for control volume advection of field (NDISOT)

Should be a 2-to-4-digit number

1st digit (optional) : 1 to improve efficiency of upwind value calculation

2nd&amp;3rd digits       : Number of nonlinear iterations over advection equation

4th digit            : Discretisation option (see below)

4th DIGIT Method for face-value est.   Time-stepping     Limiting
------------------------------------------------------------------
  =0      1st order in space          Theta=specified    UNIVERSAL
  =1      1st order in space          Theta=non-linear   UNIVERSAL
  =2      Trapazoidal rule in space   Theta=specified    UNIVERSAL
  =3      Trapazoidal rule in space   Theta=non-linear   UNIVERSAL
  =4      Finite elements in space    Theta=specified    UNIVERSAL
  =5      Finite elements in space    Theta=non-linear   UNIVERSAL
  =6      Finite elements in space    Theta=specified    NONE
  =7      Finite elements in space    Theta=non-linear   NONE
  =8      Finite elements in space    Theta=specified    DOWNWIND+
  =9      Finite elements in space    Theta=non-linear   DOWNWIND+</a:documentation>
              <attribute name="replaces">
                <value>NDISOT</value>
              </attribute>
              <ref name="integer"/>
            </element>
          </optional>
        </element>
      </choice>
      <element name="conservative_advection">
        <a:documentation>Conservative discretisation of field advection equation
TBETA=1. -- conservative (divergence form)
TBETA=0. -- non-conservative
0. &lt; TBETA &lt; 1.</a:documentation>
        <attribute name="replaces">
          <value>TBETA, DEFALT (TBETA = 0.0)</value>
        </attribute>
        <ref name="real"/>
      </element>
    </element>
    <element name="temporal_discretisation">
      <element name="theta">
        <a:documentation>Implicit/explicit control (TTHETA)
=0.  -- explicit
=0.5 -- Crank-Nicholson
=1.  -- implicit</a:documentation>
        <attribute name="replaces">
          <value>TTHETA, DEFALT (TTHETA = 0.5)</value>
        </attribute>
        <ref name="real"/>
      </element>
      <optional>
        <ref name="temporal_control_volume_options"/>
      </optional>
      <optional>
        <element name="explicit_advection">
          <a:documentation>Treat advection terms explicity and therefore make matrix symmetric</a:documentation>
          <attribute name="replaces">
            <value>TSYM, DEFALT (TSYM=FALSE), DIFF (TSYM=TRUE)</value>
          </attribute>
        </element>
      </optional>
    </element>
    <element name="solver">
      <a:documentation>Solver</a:documentation>
      <ref name="linear_solver_options"/>
      <optional>
        <element name="legacy">
          <a:documentation>Legacy solver options
If selected legacy solvers solcg and gmres will be used
to solve the linear equations, otherwise PETSc is used.</a:documentation>
          <element name="max_iterations_outer">
            <a:documentation>Maximum number of iterations for tracer field solution
DDM iterations if parallel
Manual suggests 700</a:documentation>
            <attribute name="replaces">
              <value>TNOIT1</value>
            </attribute>
            <ref name="integer"/>
          </element>
          <element name="max_iterations_inner">
            <a:documentation>Maximum number of iterations for tracer field solution
Internal iterations if parallel
Manual suggests 700</a:documentation>
            <attribute name="replaces">
              <value>TNOIT2</value>
            </attribute>
            <ref name="integer"/>
          </element>
          <element name="max_nonrestarted_iterations_outer">
            <a:documentation>Maximum number of non-restarted outer iterations
Manual suggests 10</a:documentation>
            <attribute name="replaces">
              <value>TMINT1</value>
            </attribute>
            <ref name="integer"/>
          </element>
          <element name="max_nonrestarted_iterations_inner">
            <a:documentation>Maximum number of non-restarted inner iterations
Manual suggests 10</a:documentation>
            <attribute name="replaces">
              <value>TMINT2</value>
            </attribute>
            <ref name="integer"/>
          </element>
          <element name="tolerance_outer">
            <a:documentation>Tolerance for outer iteration of tracer field solution
Manual suggests 1.E-10</a:documentation>
            <attribute name="replaces">
              <value>TEROR1</value>
            </attribute>
            <ref name="real"/>
          </element>
          <element name="tolerance_inner">
            <a:documentation>Tolerance for inner iteration of tracer field solution
Manual suggests 1.E-10</a:documentation>
            <attribute name="replaces">
              <value>TEROR2</value>
            </attribute>
            <ref name="real"/>
          </element>
          <element name="field_no_outer_iterations_ddm">
            <a:documentation>miss out outeriterations for DDM solution.
Manual suggests 0</a:documentation>
            <attribute name="replaces">
              <value>TMISOU</value>
            </attribute>
            <ref name="integer"/>
          </element>
        </element>
      </optional>
    </element>
    <optional>
      <element name="tensor_field">
        <a:documentation>Diffusivity for field</a:documentation>
        <attribute name="name">
          <value>Diffusivity</value>
        </attribute>
        <attribute name="rank">
          <value>2</value>
        </attribute>
        <attribute name="replaces">
          <value>TMUXX TMUYY TMUZZ TMUYZ TMUXZ TMUXY TALLMU TCONMU</value>
        </attribute>
        <element name="prescribed">
          <ref name="prescribed_values_tensor_field"/>
        </element>
      </element>
    </optional>
    <optional>
      <element name="scalar_field">
        <a:documentation>source term</a:documentation>
        <attribute name="name">
          <value>Source</value>
        </attribute>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="replaces">
          <value>ZSOT</value>
        </attribute>
        <element name="diagnostic">
          <ref name="diagnostic_scalar_field"/>
        </element>
      </element>
    </optional>
    <optional>
      <element name="scalar_field">
        <a:documentation>Absorption term</a:documentation>
        <attribute name="name">
          <value>Absorption</value>
        </attribute>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="replaces">
          <value>TABSZE TABS TABSCO TABSOR</value>
        </attribute>
        <element name="diagnostic">
          <ref name="diagnostic_scalar_field"/>
        </element>
      </element>
    </optional>
    <ref name="prognostic_scalar_output_options"/>
    <ref name="prognostic_scalar_stat_options"/>
    <ref name="scalar_convergence_options"/>
    <ref name="adaptivity_options_scalar_field"/>
  </define>
  <!--
    stream function, this is a copy of prognostic_scalar_field above
    removing all options that don't apply (mainly advection related)
  -->
  <define name="prognostic_stream_function_field">
    <element name="solver">
      <a:documentation>Solver</a:documentation>
      <ref name="linear_solver_options"/>
    </element>
    <!--
      no Diffusivity for field
      no source term
      no Absorption term
      no Adaptive timestepping option
    -->
    <ref name="prognostic_scalar_output_options"/>
    <ref name="prognostic_scalar_stat_options"/>
    <ref name="adaptivity_options_scalar_field"/>
  </define>
  <!-- three optional input vectors for user-specified rotation matrix -->
  <define name="rotation_matrix_components">
    <optional>
      <element name="normal_direction">
        <a:documentation>Select if you want to specify the normal direction
of the rotation matrix.
If off then fluidity computes the normal (replaces GETTAN = .TRUE.)
If on the tangents vectors must also be specified.</a:documentation>
        <attribute name="replaces">
          <value>GETTAN=.FALSE.</value>
        </attribute>
        <ref name="input_choice_real_dim_vector"/>
      </element>
    </optional>
    <optional>
      <element name="tangent_direction_1">
        <a:documentation>specify first unit tangent vector to boundary</a:documentation>
        <attribute name="replaces">
          <value>GETTAN=.FALSE.</value>
        </attribute>
        <ref name="input_choice_real_dim_vector"/>
      </element>
    </optional>
    <optional>
      <element name="tangent_direction_2">
        <a:documentation>specify second (if exists, i.e. if 3d) unit tangent vector to boundary</a:documentation>
        <attribute name="replaces">
          <value>GETTAN=.FALSE.</value>
        </attribute>
        <ref name="input_choice_real_dim_vector"/>
      </element>
    </optional>
  </define>
  <define name="velocity_components_choice">
    <choice>
      <element name="align_bc_with_surface">
        <optional>
          <element name="normal_component">
            <ref name="input_choice_real"/>
          </element>
        </optional>
        <optional>
          <element name="tangent_component_1">
            <ref name="input_choice_real"/>
          </element>
        </optional>
        <optional>
          <element name="tangent_component_2">
            <ref name="input_choice_real"/>
          </element>
        </optional>
        <ref name="rotation_matrix_components"/>
      </element>
      <element name="align_bc_with_cartesian">
        <optional>
          <element name="x_component">
            <ref name="input_choice_real"/>
          </element>
        </optional>
        <optional>
          <element name="y_component">
            <ref name="input_choice_real"/>
          </element>
        </optional>
        <optional>
          <element name="z_component">
            <ref name="input_choice_real"/>
          </element>
        </optional>
      </element>
    </choice>
  </define>
  <!-- and again for robin b.c.s -->
  <define name="robin_velocity_components_choice">
    <choice>
      <element name="align_bc_with_surface">
        <optional>
          <element name="normal_component">
            <element name="order_zero_coefficient">
              <ref name="input_choice_real"/>
            </element>
            <element name="order_one_coefficient">
              <ref name="input_choice_real"/>
            </element>
          </element>
        </optional>
        <optional>
          <element name="tangent_component_1">
            <element name="order_zero_coefficient">
              <ref name="input_choice_real"/>
            </element>
            <element name="order_one_coefficient">
              <ref name="input_choice_real"/>
            </element>
          </element>
        </optional>
        <optional>
          <element name="tangent_component_2">
            <element name="order_zero_coefficient">
              <ref name="input_choice_real"/>
            </element>
            <element name="order_one_coefficient">
              <ref name="input_choice_real"/>
            </element>
          </element>
        </optional>
        <ref name="rotation_matrix_components"/>
      </element>
      <element name="align_bc_with_cartesian">
        <optional>
          <element name="x_component">
            <element name="order_zero_coefficient">
              <ref name="input_choice_real"/>
            </element>
            <element name="order_one_coefficient">
              <ref name="input_choice_real"/>
            </element>
          </element>
        </optional>
        <optional>
          <element name="y_component">
            <element name="order_zero_coefficient">
              <ref name="input_choice_real"/>
            </element>
            <element name="order_one_coefficient">
              <ref name="input_choice_real"/>
            </element>
          </element>
        </optional>
        <optional>
          <element name="z_component">
            <element name="order_zero_coefficient">
              <ref name="input_choice_real"/>
            </element>
            <element name="order_one_coefficient">
              <ref name="input_choice_real"/>
            </element>
          </element>
        </optional>
      </element>
    </choice>
  </define>
  <define name="velocity_boundary_conditions">
    <choice>
      <element name="type">
        <attribute name="name">
          <value>dirichlet</value>
        </attribute>
        <ref name="velocity_components_choice"/>
      </element>
      <element name="type">
        <attribute name="name">
          <value>neumann</value>
        </attribute>
        <ref name="velocity_components_choice"/>
      </element>
      <element name="type">
        <attribute name="name">
          <value>robin</value>
        </attribute>
        <ref name="robin_velocity_components_choice"/>
      </element>
      <element name="type">
        <a:documentation>Apply quadratic drag. Specify drag coefficient.</a:documentation>
        <attribute name="name">
          <value>drag</value>
        </attribute>
        <ref name="input_choice_real"/>
      </element>
      <element name="type">
        <a:documentation>Apply wind forcing specified by stress or wind velocity.
Replaces windy.dat and windy.py</a:documentation>
        <attribute name="name">
          <value>wind_forcing</value>
        </attribute>
        <choice>
          <element name="wind_stress">
            <ref name="input_choice_real_dim_minus_one_vector"/>
          </element>
          <element name="wind_velocity">
            <a:documentation>NOTE: this isn't coded yet</a:documentation>
            <ref name="input_choice_real_dim_minus_one_vector"/>
          </element>
        </choice>
      </element>
    </choice>
  </define>
  <!-- Output options for prognostic fields -->
  <define name="prognostic_scalar_output_options">
    <element name="output">
      <a:documentation>Specify what is written to vtu dump files</a:documentation>
      <optional>
        <element name="exclude_from_vtu">
          <a:documentation>By default each field in the options file is written to vtu.
Select this option to exclude this field.</a:documentation>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="include_previous_time_step">
          <a:documentation>Select this option to also write the values of this field on the previous timestep.
(included under the name: Old&lt;field_name&gt; )</a:documentation>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="include_nonlinear_field">
          <a:documentation>Select this option to also write the values of this field used in the nonlinear iteration.
(included under the name: Nonlinear&lt;field_name&gt; )</a:documentation>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="convergence_file">
          <ref name="comment"/>
        </element>
      </optional>
    </element>
  </define>
  <!-- Output options for prognostic fields -->
  <define name="prognostic_vector_output_options">
    <element name="output">
      <a:documentation>Specify what is written to vtu dump files</a:documentation>
      <optional>
        <element name="exclude_from_vtu">
          <a:documentation>By default each field in the options file is written to vtu.
Select this option to exclude this field.</a:documentation>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="include_previous_time_step">
          <a:documentation>Select this option to also write the values of this field on the previous timestep.
(included under the name: Old&lt;field_name&gt; )</a:documentation>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="include_nonlinear_field">
          <a:documentation>Select this option to also write the values of this field used in the nonlinear iteration.
(included under the name: Nonlinear&lt;field_name&gt; )</a:documentation>
          <empty/>
        </element>
      </optional>
    </element>
  </define>
  <!-- Output options for all other fields -->
  <define name="field_output_options">
    <element name="output">
      <a:documentation>Specify what is written to vtu dump files</a:documentation>
      <optional>
        <element name="exclude_from_vtu">
          <a:documentation>By default each field in the options file is written to vtu.
Select this option to exclude this field.</a:documentation>
          <empty/>
        </element>
      </optional>
    </element>
  </define>
  <define name="diagnostic_output_options">
    <ref name="field_output_options"/>
  </define>
  <define name="prescribed_output_options">
    <ref name="field_output_options"/>
  </define>
  <!-- Option indicating that this field should be excluded from the .stat file -->
  <define name="exclude_stat">
    <element name="exclude_from_stat">
      <a:documentation>Enable to exclude this field from the .stat file.</a:documentation>
      <ref name="comment"/>
    </element>
  </define>
  <!-- Diagnostic statistics options for prognostic scalar fields -->
  <define name="prognostic_scalar_stat_options">
    <element name="stat">
      <a:documentation>Specify what is added to .stat files</a:documentation>
      <optional>
        <ref name="exclude_stat"/>
      </optional>
      <optional>
        <element name="include_previous_time_step">
          <a:documentation>Enable to include the previous timestep value of this field in the .stat file.</a:documentation>
          <ref name="comment"/>
        </element>
      </optional>
      <optional>
        <element name="include_nonlinear_field">
          <a:documentation>Enable to include the values of this field in the nonlinear iteration in the .stat file.</a:documentation>
          <ref name="comment"/>
        </element>
      </optional>
    </element>
  </define>
  <!-- Convergence options for prognostic scalar fields -->
  <define name="scalar_convergence_options">
    <element name="convergence">
      <a:documentation>Decide whether this field is tested for convergence
during nonlinear iterations
(if /timestepping/nonlinear_iterations and
/timestepping/nonlinear_iterations/tolerance are
enabled).
Also specifies whether the field is added to the 
convergence file (if /io/convergence_file is enabled).</a:documentation>
      <choice>
        <element name="include_in_convergence">
          <a:documentation>Include this field in convergence testing
(if /timestepping/nonlinear_iterations and
/timestepping/nonlinear_iterations/tolerance are
enabled) and file (if /io/convergence_file is enabled)</a:documentation>
          <ref name="comment"/>
        </element>
        <element name="exclude_from_convergence">
          <a:documentation>Exclude this field from convergence testing and file </a:documentation>
          <ref name="comment"/>
        </element>
      </choice>
    </element>
  </define>
  <!-- Convergence statistics options for prognostic vector fields (velocity) -->
  <define name="vector_convergence_options">
    <element name="convergence">
      <a:documentation>Decide whether this field is tested for convergence
during nonlinear iterations
(if /timestepping/nonlinear_iterations and
/timestepping/nonlinear_iterations/tolerance are
enabled).
Also specifies whether the field is added to the 
convergence file (if /io/convergence_file is enabled).</a:documentation>
      <choice>
        <element name="include_in_convergence">
          <a:documentation>Include this field (magnitude and components)
in convergence testing
(if /timestepping/nonlinear_iterations and
/timestepping/nonlinear_iterations/tolerance are
enabled) and file (if /io/convergence_file is enabled)</a:documentation>
          <ref name="comment"/>
        </element>
        <element name="exclude_components_from_convergence">
          <a:documentation>Include just the magnitude of this field 
in convergence testing
(if /timestepping/nonlinear_iterations and
/timestepping/nonlinear_iterations/tolerance are
enabled) and file (if /io/convergence_file is enabled)
i.e. excluding the components</a:documentation>
          <ref name="comment"/>
        </element>
        <element name="exclude_from_convergence">
          <a:documentation>Exclude this field entirely from convergence testing and file </a:documentation>
          <ref name="comment"/>
        </element>
      </choice>
    </element>
  </define>
  <!-- Diagnostic statistics for all other scalar fields -->
  <define name="prognostic_scalar_stat_no_old_or_nonlinear_options">
    <element name="stat">
      <a:documentation>Specify what is added to .stat files</a:documentation>
      <optional>
        <ref name="exclude_stat"/>
      </optional>
    </element>
  </define>
  <define name="diagnostic_scalar_stat_options">
    <ref name="prognostic_scalar_stat_no_old_or_nonlinear_options"/>
  </define>
  <define name="prescribed_scalar_stat_options">
    <ref name="prognostic_scalar_stat_no_old_or_nonlinear_options"/>
  </define>
  <!-- .stat options for vector fields, with enabled by default -->
  <define name="vector_field_stat_options_enabled_default">
    <choice>
      <element name="include_in_stat">
        <a:documentation>Include this field in the .stat file (magnitude and components)</a:documentation>
        <ref name="comment"/>
      </element>
      <element name="exclude_components_from_stat">
        <a:documentation>Include just the magnitude of this field in the .stat file (excluding the components)</a:documentation>
        <ref name="comment"/>
      </element>
      <element name="exclude_from_stat">
        <a:documentation>Exclude this field entirely from the .stat file</a:documentation>
        <ref name="comment"/>
      </element>
    </choice>
  </define>
  <!-- .stat options for vector fields, with disabled by default -->
  <define name="vector_field_stat_options_disabled_default">
    <choice>
      <element name="exclude_from_stat">
        <a:documentation>Exclude this field entirely from the .stat file</a:documentation>
        <ref name="comment"/>
      </element>
      <element name="exclude_components_from_stat">
        <a:documentation>Include just the magnitude of this field in the .stat file (excluding the components)</a:documentation>
        <ref name="comment"/>
      </element>
      <element name="include_in_stat">
        <a:documentation>Include this field in the .stat file (magnitude and components)</a:documentation>
        <ref name="comment"/>
      </element>
    </choice>
  </define>
  <!-- Diagnostic statistics for prognostic vector fields -->
  <define name="prognostic_vector_stat_options">
    <element name="stat">
      <a:documentation>Specify what is added to .stat files</a:documentation>
      <ref name="vector_field_stat_options_enabled_default"/>
      <element name="previous_time_step">
        <a:documentation>Specify how the previous timestep value of this field is added to the .stat file.</a:documentation>
        <ref name="vector_field_stat_options_disabled_default"/>
      </element>
      <element name="nonlinear_field">
        <a:documentation>Specify how the values of this field used in the nonlinear iteration are added to the .stat file.</a:documentation>
        <ref name="vector_field_stat_options_disabled_default"/>
      </element>
    </element>
  </define>
  <!-- Diagnostic statistics for all other vector fields -->
  <define name="prognostic_vector_stat_no_old_or_nonlinear_options">
    <element name="stat">
      <a:documentation>Specify what is added to .stat files</a:documentation>
      <ref name="vector_field_stat_options_enabled_default"/>
    </element>
  </define>
  <define name="diagnostic_vector_stat_options">
    <ref name="prognostic_vector_stat_no_old_or_nonlinear_options"/>
  </define>
  <define name="prescribed_vector_stat_options">
    <ref name="prognostic_vector_stat_no_old_or_nonlinear_options"/>
  </define>
  <define name="adaptivity_options_scalar_field">
    <optional>
      <element name="adaptivity_options">
        <choice>
          <element name="absolute_measure">
            <attribute name="replaces">
              <value>ADOPTT = 0</value>
            </attribute>
            <element name="scalar_field">
              <attribute name="rank">
                <value>0</value>
              </attribute>
              <attribute name="name">
                <value>InterpolationErrorBound</value>
              </attribute>
              <attribute name="replaces">
                <value>ADWEIT</value>
              </attribute>
              <element name="prescribed">
                <ref name="prescribed_scalar_field_no_adapt"/>
              </element>
            </element>
          </element>
          <element name="relative_measure">
            <attribute name="replaces">
              <value>ADOPTT = 1</value>
            </attribute>
            <element name="scalar_field">
              <attribute name="rank">
                <value>0</value>
              </attribute>
              <attribute name="name">
                <value>InterpolationErrorBound</value>
              </attribute>
              <attribute name="replaces">
                <value>ADADOT</value>
              </attribute>
              <element name="prescribed">
                <ref name="prescribed_scalar_field_no_adapt"/>
              </element>
            </element>
            <element name="tolerance">
              <a:documentation>The relative Hessian is calculated according to:

  Q = H / max{ |psi|, psi_min}

where H is the Hessian, psi is the field value and psi_min is the tolerance. The tolerance prevents division by zero errors.

Source: Fluidity/ICOM manual draft version 1.2</a:documentation>
              <attribute name="replaces">
                <value>ADATOT</value>
              </attribute>
              <ref name="real"/>
            </element>
          </element>
        </choice>
        <optional>
          <element name="lp_norm">
            <a:documentation>Normally, adaptivity optimises the mesh to minimise
the L_\infty norm. By specifying p here, you can
instruct adaptivity to optimise the mesh for
the L_p norm instead.

See
F. Alauzet et al.
Multi-Dimensional Continuous Metric for Mesh Adaptation
Proceedings of the 15th International Meshing Roundtable</a:documentation>
            <ref name="real"/>
          </element>
        </optional>
      </element>
    </optional>
  </define>
  <define name="adaptivity_options_vector_field">
    <optional>
      <element name="adaptivity_options">
        <a:documentation>Adaptivity weights</a:documentation>
        <choice>
          <element name="absolute_measure">
            <element name="vector_field">
              <attribute name="rank">
                <value>1</value>
              </attribute>
              <attribute name="name">
                <value>InterpolationErrorBound</value>
              </attribute>
              <attribute name="replaces">
                <value>ADWEIU ADWEIV ADWEIW</value>
              </attribute>
              <element name="prescribed">
                <ref name="prescribed_vector_field_no_adapt"/>
              </element>
            </element>
          </element>
          <element name="relative_measure">
            <element name="vector_field">
              <attribute name="rank">
                <value>1</value>
              </attribute>
              <attribute name="name">
                <value>InterpolationErrorBound</value>
              </attribute>
              <attribute name="replaces">
                <value>ADATOU ADATOV ADATOW</value>
              </attribute>
              <element name="prescribed">
                <ref name="prescribed_vector_field_no_adapt"/>
              </element>
            </element>
            <element name="tolerance">
              <a:documentation>The relative Hessian is calculated according to:

  Q = H / max{ |psi|, psi_min}

where H is the Hessian, psi is the field value and psi_min is the tolerance. The tolerance prevents division by zero errors.

Source: Fluidity/ICOM manual draft version 1.2</a:documentation>
              <ref name="real_dim_vector"/>
            </element>
          </element>
        </choice>
        <optional>
          <element name="lp_norm">
            <a:documentation>Normally, adaptivity optimises the mesh to minimise
the L_\infty norm. By specifying p here, you can
instruct adaptivity to optimise the mesh for
the L_p norm instead.

See
F. Alauzet et al.
Multi-Dimensional Continuous Metric for Mesh Adaptation
Proceedings of the 15th International Meshing Roundtable</a:documentation>
            <ref name="real"/>
          </element>
        </optional>
      </element>
    </optional>
  </define>
  <define name="adaptivity_options_tensor_field">
    <optional>
      <element name="adaptivity_options">
        <a:documentation>Adaptivity weights</a:documentation>
        <choice>
          <element name="absolute_measure">
            <element name="tensor_field">
              <attribute name="rank">
                <value>2</value>
              </attribute>
              <attribute name="name">
                <value>InterpolationErrorBound</value>
              </attribute>
              <element name="prescribed">
                <ref name="prescribed_values_tensor_field"/>
              </element>
            </element>
          </element>
          <element name="relative_measure">
            <element name="tensor_field">
              <attribute name="rank">
                <value>2</value>
              </attribute>
              <attribute name="name">
                <value>InterpolationErrorBound</value>
              </attribute>
              <element name="prescribed">
                <ref name="prescribed_values_tensor_field"/>
              </element>
            </element>
            <element name="tolerance">
              <a:documentation>The relative Hessian is calculated according to:

  Q = H / max{ |psi|, psi_min}

where H is the Hessian, psi is the field value and psi_min is the tolerance. The tolerance prevents division by zero errors.

Source: Fluidity/ICOM manual draft version 1.2</a:documentation>
              <ref name="real_dim_tensor"/>
            </element>
          </element>
        </choice>
        <optional>
          <element name="lp_norm">
            <a:documentation>Normally, adaptivity optimises the mesh to minimise
the L_\infty norm. By specifying p here, you can
instruct adaptivity to optimise the mesh for
the L_p norm instead.

See
F. Alauzet et al.
Multi-Dimensional Continuous Metric for Mesh Adaptation
Proceedings of the 15th International Meshing Roundtable</a:documentation>
            <ref name="real"/>
          </element>
        </optional>
      </element>
    </optional>
  </define>
  <define name="generic_aliased_field">
    <attribute name="material_phase_name">
      <data type="string"/>
    </attribute>
    <attribute name="field_name">
      <data type="string"/>
    </attribute>
  </define>
  <define name="mesh_choice">
    <!-- Most common mesh choices -->
    <choice>
      <element name="mesh">
        <attribute name="name">
          <data type="string"/>
        </attribute>
      </element>
      <element name="mesh">
        <attribute name="name">
          <value>CoordinateMesh</value>
        </attribute>
      </element>
      <element name="mesh">
        <attribute name="name">
          <value>VelocityMesh</value>
        </attribute>
      </element>
      <element name="mesh">
        <attribute name="name">
          <value>PressureMesh</value>
        </attribute>
      </element>
    </choice>
  </define>
  <!--
    Not really a choice, for fields that have to be on the velocity mesh
    currently that's all scalar fields, except pressure
    and of course velocity itself
    If you want to implement scalar fields on other meshes, feel free to do so
    but bare in mind you need to make sure the field stays outside RMEM.
    Currently all scalar fields are packed in RMEM with length nonods
  -->
  <define name="velocity_mesh_choice">
    <element name="mesh">
      <attribute name="name">
        <value>VelocityMesh</value>
      </attribute>
    </element>
  </define>
  <!-- This is the choice of additional scalar field to be solved for -->
  <define name="scalar_field_choice">
    <!--
      The first is a generic field, used for any user-defined field that
      FLUIDITY knows nothing about.  Therefore, this field cannot be diagnostic.
    -->
    <choice>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <data type="string"/>
        </attribute>
        <choice>
          <a:documentation>Field type</a:documentation>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="prognostic_scalar_field"/>
          </element>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="___Prognostic_Fields_Below___">
        <a:documentation>Prognostic scalar fields below this</a:documentation>
        <empty/>
      </element>
      <!--
        This is the long list of fields that FLUIDITY knows about
        - - First is a list of fields that are primarily prognostic,
           but can be set to diagnostic, or aliased...
        - - The list is in order of most frequently used.
      -->
      <element name="scalar_field">
        <a:documentation>Salinity</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>Salinity</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = 42</value>
        </attribute>
        <choice>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="prognostic_scalar_field"/>
          </element>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Temperature</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>Temperature</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = -1</value>
        </attribute>
        <choice>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="prognostic_scalar_field"/>
          </element>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Passive Tracer</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>Tracer</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = 666</value>
        </attribute>
        <choice>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="prognostic_scalar_field"/>
          </element>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Kinetic Energy</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>KineticEnergy</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = 101</value>
        </attribute>
        <choice>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="prognostic_mellor_yamada_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Turbulent Length Scale x Kinetic Energy</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>TurbulentLengthScalexKineticEnergy</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = 102</value>
        </attribute>
        <choice>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="prognostic_mellor_yamada_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Vertical Viscosity</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>VerticalViscosity</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = 103</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Vertical Diffusivity of Temperature</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>VerticalDiffusivity</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = 104</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Free Surface</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>FreeSurface</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = -29</value>
        </attribute>
        <element name="prognostic">
          <element name="mesh">
            <a:documentation>Note that this is not the quadratic mesh balance pressure is
actually calculated on, but the linear mesh it's projected back
on for output purposes.</a:documentation>
            <attribute name="name">
              <value>VelocityMesh</value>
            </attribute>
          </element>
          <ref name="prognostic_free_surface_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>Old Free Surface</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>LegacyFreeSurface</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = -30</value>
        </attribute>
        <choice>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="prognostic_scalar_field"/>
          </element>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Second Fluid</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>SecondFluid</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = 56</value>
        </attribute>
        <choice>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="prognostic_scalar_field"/>
          </element>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Diffuse Interface</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>DiffuseInterface</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = 57</value>
        </attribute>
        <choice>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="prognostic_scalar_field"/>
          </element>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>BalancePressure</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = -2003</value>
        </attribute>
        <element name="prognostic">
          <!--
            Note the assumptions about quadratic/linear below and hard-coding
            of the mesh, this is because of restrictions of the
            current code, will change in the near future.
          -->
          <element name="mesh">
            <a:documentation>Note that this is not the quadratic mesh balance pressure is
actually calculated on, but the linear mesh it's projected back
on for output purposes.</a:documentation>
            <attribute name="name">
              <value>VelocityMesh</value>
            </attribute>
          </element>
          <ref name="prognostic_balance_pressure_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>MaterialVolumeFraction field:
Volume fraction of this material.
Required in multimaterial simulations.
- if prognostic solves for the volume fraction
- if prescribed uses a specified volume fraction
- if diagnostic solves for the final material volume fraction
  Only 1 diagnostic MaterialVolumeFraction field allowed per
  simulation.
  A diagnostic MaterialVolumeFraction field is currently required for
  compressible multimaterial simulations (even if only 1 material).
Generally also requires a MaterialDensity field.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>MaterialVolumeFraction</value>
        </attribute>
        <choice>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="prognostic_scalar_field"/>
            <ref name="cap_option"/>
          </element>
          <element name="diagnostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
            <ref name="cap_option"/>
          </element>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
            <ref name="cap_option"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>MaterialDensity field:
Field for the density of this material.
Required in multimaterial simulations.
- prescribed if an incompressible simulation
- prognostic if a compressible simulation
  (note that if you set a multimaterial
  equation of state and this field is
  prognostic then its initial condition
  will be overwritten by the density that
  satisfies the initial pressure and
  the equation of state)</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>MaterialDensity</value>
        </attribute>
        <choice>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="prognostic_scalar_field"/>
          </element>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>MaterialInternalEnergy field:
Field for the internal energy of this material.
Required in multimaterial compressible simulations
with full miegrunneisen (perfect gas) eos.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>MaterialInternalEnergy</value>
        </attribute>
        <choice>
          <element name="prognostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="prognostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>CopiedField - This field copies the previous timesteps
values from another (specified) field at every iteration
and then solves the field using different (again, specified)
scheme and solution options.
For instance, this field can be used to create a diffused
field to adapt to.
Unless someone requests otherwise this is only currently possible
for fields within the same material_phase.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>CopiedField</value>
        </attribute>
        <element name="prognostic">
          <ref name="velocity_mesh_choice"/>
          <ref name="copied_field_options"/>
          <ref name="prognostic_scalar_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>Calculate the stream function of 2D incompressible flow. Note 
that this *only* makes sense for propper 2D (not pseudo-2D) simulations.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>StreamFunction</value>
        </attribute>
        <element name="prognostic">
          <ref name="mesh_choice"/>
          <ref name="prognostic_stream_function_field"/>
        </element>
      </element>
      <!--
        Insert new prognostic scalar fields here using the template:
               element scalar_field {
                   attribute rank { "0" },
                   attribute name { "NewFieldName" },
                   (
                      element prognostic {
                         velocity_mesh_choice,
                         prognostic_scalar_field
                      }|
                      element prescribed {
                         velocity_mesh_choice,
                         prescribed_scalar_field
                      }|
                      element aliased {
                         generic_aliased_field
                      }
                   )
               }
      -->
      <!--
        - - Second is a list of fields that are primarily prescribed,
           but can be aliased. An example is wind velocity.
        - - The list is in order of most frequently used.
      -->
      <element name="___Prescribed_fields_below___">
        <a:documentation>Prescribed scalar fields below this</a:documentation>
        <empty/>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>MeshLockingFunction</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = -40</value>
        </attribute>
        <choice>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>NodestoRotate</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = -41</value>
        </attribute>
        <choice>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>NodesonTop</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = -43</value>
        </attribute>
        <choice>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>NodesonBottom</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = -44</value>
        </attribute>
        <choice>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>NonesforNonzeroFreeSurfaceBC</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = -45</value>
        </attribute>
        <choice>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>WindVelocityX</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = -101</value>
        </attribute>
        <choice>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>WindVelocityY</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = -102</value>
        </attribute>
        <choice>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>SurfaceTemperatureFlux</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = -103</value>
        </attribute>
        <choice>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>VolumeTemperatureSource</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = -123</value>
        </attribute>
        <choice>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>DistanceToSideBoundaries</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = -144</value>
        </attribute>
        <choice>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>InitialTemperature</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = -194</value>
        </attribute>
        <choice>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>MaterialFrictionAngle for multimaterial
plasticity problems
Requires a diagnostic bulk FrictionAngle field
- not tested yet</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>MaterialFrictionAngle</value>
        </attribute>
        <choice>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>MaterialCohesion for multimaterial
plasticity problems
Requires a diagnostic bulk Cohesion field
- not tested yet</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>MaterialCohesion</value>
        </attribute>
        <choice>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <!--
        
        Insert new prescribed scalar fields here using the template:
               element scalar_field {
                   attribute rank { "0" },
                   attribute name { "NewFieldName" },
                   (
                      element prescribed {
                         velocity_mesh_choice,
                         prescribed_scalar_field
                      }|
                      element aliased {
                         generic_aliased_field
                      }
                   )
               }
        
        - - Last is a list of fields that are primarily diagnostic,
           but can be aliased. An example is Tidal Range.
        - - The list is in order of most frequently used.
        
      -->
      <element name="___Diagnostic_Fields_Below___">
        <a:documentation>Diagnostic scalar fields below this</a:documentation>
        <empty/>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>PerturbationDensity</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = -143</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>EquilibriumTide</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = -31</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>TidalRange</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = -32</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>MaxFreeSurface</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = -33</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>MinFreeSurface</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = -34</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>Phase</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = -35</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>MaxBedShearStressX</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = -36</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>MaxBedShearStressY</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = -37</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>MaxBedShearStressZ</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = -38</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>TidalCurrentEllipse11</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = -51</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>TidalCurrentEllipse12</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = -52</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>TidalCurrentEllipse13</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = -53</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>TidalCurrentEllipse21</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = -54</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>TidalCurrentEllipse22</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = -55</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>TidalCurrentEllipse23</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = -56</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>TidalCurrentEllipse31</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = -57</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>TidalCurrentEllipse32</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = -58</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>TidalCurrentEllipse33</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = -59</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>M2Amplitude</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = -61</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>S2Amplitude</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = -62</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>N2Amplitude</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = -63</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>K2Amplitude</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = -64</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>K1Amplitude</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = -65</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>O1Amplitude</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = -66</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>P1Amplitude</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = -67</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>Q1Amplitude</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = -68</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>M2Phase</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = -71</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>S2Phase</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = -72</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>N2Phase</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = -73</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>K2Phase</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = -74</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>K1Phase</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = -75</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>O1Phase</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = -76</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>P1Phase</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = -77</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>Q1Phase</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = -78</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>MeanBedShearStressX</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = -136</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>MeanBedShearStressY</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = -137</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>MeanBedShearStressZ</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = -138</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>HarmonicVelocityX</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = -181</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>HarmonicVelocityY</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = -182</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>HarmonicVelocityZ</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = -183</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>ShearRichardsonNumber</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = -600</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>CFLNumber

See http://amcg.ese.ic.ac.uk/index.php?title=Local:Diagnostics#CFL_Number

Adapting to this field is not recommended</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>CFLNumber</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = -601</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>ControlVolumeCFLNumber

Courant Number as defined on a control volume mesh

Adapting to this field is not recommended</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>ControlVolumeCFLNumber</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>SolidConcentration</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>This scalar field is meant to replace DENTRAF.
Basically, if you use new options, DENTRAF is no longer needed
No repointing is done from this field to DENTRAF.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>CopyofDensity</value>
        </attribute>
        <attribute name="replaces">
          <value>DENTRAF</value>
        </attribute>
        <element name="diagnostic">
          <ref name="velocity_mesh_choice"/>
          <ref name="diagnostic_scalar_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>Add field to be used by Solid_configuration to 
Visualize the solids and MaterialVolumeFraction together</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>VisualizeConcentrations</value>
        </attribute>
        <element name="diagnostic">
          <ref name="velocity_mesh_choice"/>
          <ref name="diagnostic_scalar_field"/>
        </element>
      </element>
      <element name="scalar_field">
        <a:documentation>SumMaterialVolumeFractions field:
Sums the MaterialVolumeFraction fields of all
material_phases.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>SumMaterialVolumeFractions</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>add a MaterialMass scalar_field to calculate the spatially varying 
mass of a material (requires a MaterialVolumeFraction and a MaterialDensity)</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>MaterialMass</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Calculates the MaterialPressure based on the MaterialDensity
(and MaterialInternalEnergy if appropriate) for the equation
of state of this material.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>MaterialPressure</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Calculates the BulkMaterialPressure based on the MaterialDensity
and MaterialVolumeFraction (and MaterialInternalEnergy if appropriate) 
for the equation of state of all materials.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>BulkMaterialPressure</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <!--
        Reynolds number: |(u dot nabla) u| / |(nabla nu nabla) u|
        element scalar_field {
           attribute rank { "1" },
           attribute name { "ReynoldsNumber" },
           (
              element diagnostic {
                 element mesh {
                   attribute name {  "VelocityMesh" }
                 },
                 diagnostic_scalar_field
              }|
              element aliased {
                 generic_aliased_field
              }
           )
        }|
      -->
      <element name="scalar_field">
        <a:documentation>Horizontal velocity divergence:

div_H velocity

Uses the gravity field direction to determine the horizontal plane.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>HorizontalVelocityDivergence</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Velocity divergence:

div velocity
</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>VelocityDivergence</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Vorticity for a 2D field:

 du   dv
 -- - --
 dy   dx</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>Vorticity2D</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>ControlVolumeVelocityDivergence:

div Velocity

Divergence of the velocity field where
the divergence operator is defined using
control volumes.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>ControlVolumeVelocityDivergence</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Kinetic energy density:

1/2 rho |u|^2

where rho is the density.

Limitations:

- The Density, KineticEnergyDensity and Velocity fields must be on the same mesh.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>KineticEnergyDensity</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Potential energy density:

rho rho' (g dot (r - r_0))

where rho is the density, rho' is the perturbation density and r_0 is the potential energy zero point.

Limitations:

- Requires a constant gravity direction.
- The Density, PerturbationDensity and PotentialEnergyDensity fields must be on the same mesh.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>PotentialEnergyDensity</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
            <element name="zero_point">
              <a:documentation>Coordinate of a point with a potential energy of zero.</a:documentation>
              <ref name="real_dim_vector"/>
              <ref name="comment"/>
            </element>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="scalar_field">
        <a:documentation>Potential vorticity:

[(absolute vorticity) dot (- alpha grad T)] / density

where alpha is the thermal expansion coefficient. The diagnostic field AbsoluteVorticity is calculated and discarded if it is not enabled in the current material phase.

Limitations:

- Requires a linear equation of state.
- The AbsoluteVorticity, PotentialVorticity and Temperature fields must be on the same mesh.</a:documentation>
        <attribute name="rank">
          <value>0</value>
        </attribute>
        <attribute name="name">
          <value>PotentialVorticity</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="velocity_mesh_choice"/>
            <ref name="diagnostic_scalar_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
    </choice>
    <!--
      Insert new diagnostic scalar fields here using the template:
             element scalar_field {
                 attribute rank { "0" },
                 attribute name { "NewFieldName" },
                 (
                    element diagnostic {
                       velocity_mesh_choice,
                       diagnostic_scalar_field
                    }|
                    element aliased {
                       generic_aliased_field
                    }
                 )
             }
    -->
  </define>
  <!-- This is the choice of additional vector field to be solved for -->
  <define name="vector_field_choice">
    <!--
      The first is a generic field, used for any user-defined field that
      FLUIDITY knows nothing about.  Therefore, this field cannot be diagnostic.
      Prognostic vector fields are not possible (other than velocity, defined elsewhere).
    -->
    <choice>
      <element name="vector_field">
        <a:documentation>Generic field variable (vector)</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <data type="string"/>
        </attribute>
        <choice>
          <a:documentation>Field type</a:documentation>
          <element name="prescribed">
            <ref name="mesh_choice"/>
            <ref name="prescribed_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <!--
        
        - - Second is a list of fields that are primarily prescribed,
           but can be aliased. An example is Maximum bed shear stress.
        - - The list is in order of most frequently used.
        
      -->
      <element name="___Prescribed_fields_below___">
        <a:documentation>Prescribed vector fields below this</a:documentation>
        <empty/>
      </element>
      <element name="vector_field">
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>MaxBedShearStress</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = -36,-37,-38</value>
        </attribute>
        <choice>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>MeanBedShearStress</value>
        </attribute>
        <attribute name="replaces">
          <value>IDENT = -136,-137,-138</value>
        </attribute>
        <choice>
          <element name="prescribed">
            <ref name="velocity_mesh_choice"/>
            <ref name="prescribed_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <!--
        
        Insert new prescribed vector fields here using the template:
               element vector_field {
                   attribute rank { "1" },
                   attribute name { "NewFieldName" },
                   (
                      element prescribed {
                         mesh_choice,
                         prescribed_vector_field
                      }|
                      element aliased {
                         generic_aliased_field
                      }
                   )
               }
        
        - - Last is a list of fields that are primarily diagnostic,
           but can be aliased. An example is Tidal Range.
        - - The list is in order of most frequently used.
        
      -->
      <element name="___Diagnostic_Fields_Below___">
        <a:documentation>Diagnostic vector fields below this</a:documentation>
        <empty/>
      </element>
      <element name="vector_field">
        <a:documentation>Absolute vorticity:

planetary vorticity + relative vorticity

The diagnostic fields PlanetaryVorticity and Vorticity are calculated and discarded if they are not enabled in the current material phase.

Limitations:

- The AbsoluteVorticity, PlanetaryVorticity and Vorticity fields must be on the same mesh.</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>AbsoluteVorticity</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="mesh_choice"/>
            <ref name="diagnostic_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Planetary vorticity

Limitations:

- Only implemented for f and beta planes.
- Requires geometry dimension of 3.</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>PlanetaryVorticity</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <ref name="mesh_choice"/>
            <ref name="diagnostic_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="vector_field">
        <a:documentation>Relative vorticity field - curl of the velocity field

Limitations:

- Requires a geometry dimension of 3.</a:documentation>
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="name">
          <value>Vorticity</value>
        </attribute>
        <choice>
          <element name="diagnostic">
            <element name="mesh">
              <attribute name="name">
                <value>VelocityMesh</value>
              </attribute>
            </element>
            <ref name="diagnostic_vector_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <!-- Insert new diagnostic vector field here using the template: -->
      <element name="vector_field">
        <attribute name="rank">
          <value>1</value>
        </attribute>
        <attribute name="replaces">
          <value>UTRAF,VTRAF,WTRAF</value>
        </attribute>
        <attribute name="name">
          <value>SolidVelocity</value>
        </attribute>
        <element name="diagnostic">
          <ref name="mesh_choice"/>
          <ref name="diagnostic_vector_field"/>
        </element>
      </element>
    </choice>
    <!--
      Insert new diagnostic vector field here using the template:
             element vector_field {
                 attribute rank { "1" },
                 attribute name { "NewFieldName" },
                 (
                    element diagnostic {
                       mesh_choice,
                       diagnostic_vector_field
                    }|
                    element aliased {
                       generic_aliased_field
                    }
                 )
             }
    -->
  </define>
  <!-- This is the choice of additional tensor fields -->
  <define name="tensor_field_choice">
    <!--
      The first is a generic field, used for any user-defined field that
      FLUIDITY knows nothing about.  Therefore, this field cannot be diagnostic.
      Prognostic tensor fields are not possible.
    -->
    <choice>
      <element name="tensor_field">
        <a:documentation>Generic field variable (tensor)</a:documentation>
        <attribute name="rank">
          <value>2</value>
        </attribute>
        <attribute name="name">
          <data type="string"/>
        </attribute>
        <choice>
          <a:documentation>Field type</a:documentation>
          <element name="prescribed">
            <ref name="mesh_choice"/>
            <ref name="prescribed_tensor_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <!--
        
        - - Second is a list of tensor fields that are primarily prescribed,
           but can be aliased.
        - - The list is in order of most frequently used.
        
      -->
      <element name="___Prescribed_fields_below___">
        <a:documentation>Prescribed scalar fields below this</a:documentation>
        <empty/>
      </element>
      <element name="tensor_field">
        <a:documentation>MaterialViscosity field:
Field for the viscosity of this material.
Required if using a diagnostic bulk viscosity
in a multimaterial simulation.</a:documentation>
        <attribute name="rank">
          <value>2</value>
        </attribute>
        <attribute name="name">
          <value>MaterialViscosity</value>
        </attribute>
        <choice>
          <element name="prescribed">
            <ref name="mesh_choice"/>
            <ref name="prescribed_tensor_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <element name="tensor_field">
        <attribute name="rank">
          <value>2</value>
        </attribute>
        <attribute name="name">
          <value>MaterialElasticity</value>
        </attribute>
        <choice>
          <element name="prescribed">
            <ref name="mesh_choice"/>
            <ref name="prescribed_tensor_field"/>
          </element>
          <element name="aliased">
            <ref name="generic_aliased_field"/>
          </element>
        </choice>
      </element>
      <!--
        
        Insert new prescribed tensor fields here using the template:
               element tensor_field {
                   attribute rank { "2" },
                   attribute name { "NewFieldName" },
                   (
                      element prescribed {
                         mesh_choice,
                         prescribed_tensor_field
                      }|
                      element aliased {
                         generic_aliased_field
                      }
                   )
               }|
        
        - - Last is a list of fields that are primarily diagnostic,
           but can be aliased.
        - - The list is in order of most frequently used.
        
      -->
      <element name="___Diagnostic_Fields_Below___">
        <a:documentation>Diagnostic tensor fields below this</a:documentation>
        <empty/>
      </element>
    </choice>
    <!--
      Insert new diagnostic tensor field here using the template:
             element tensor_field {
                 attribute name { "NewFieldName" },
                 (
                    element diagnostic {
                       mesh_choice,
                       diagnostic_tensor_field
                    }|
                    element aliased {
                       generic_aliased_field
                    }
                 )
             }
    -->
  </define>
  <define name="mesh_info">
    <choice>
      <element name="from_file">
        <a:documentation>Read mesh from file.
For triangle files, enter the base name (i.e. without the .node, .ele or .face or .edge extensions).</a:documentation>
        <element name="format">
          <a:documentation>The format for the mesh. cgns is not yet implemented.</a:documentation>
          <element name="string_value">
            <choice>
              <value>triangle</value>
              <value>GiD_custom</value>
              <value>cgns</value>
            </choice>
          </element>
        </element>
        <attribute name="file_name">
          <data type="string"/>
        </attribute>
      </element>
      <element name="from_mesh">
        <a:documentation>Make mesh from existing mesh. The existing mesh cannot itself be made from an existing mesh (i.e. it must be read from a file).</a:documentation>
        <ref name="mesh_choice"/>
        <optional>
          <element name="mesh_shape">
            <element name="polynomial_degree">
              <ref name="integer"/>
            </element>
          </element>
        </optional>
        <optional>
          <element name="mesh_continuity">
            <element name="string_value">
              <choice>
                <value>continuous</value>
                <value>discontinuous</value>
              </choice>
            </element>
          </element>
        </optional>
        <optional>
          <element name="periodic_boundary_conditions">
            <a:documentation>Make mesh periodic</a:documentation>
            <element name="physical_boundary_ids">
              <a:documentation>List of boundary ids that are aliased to</a:documentation>
              <ref name="integer_vector"/>
            </element>
            <element name="aliased_boundary_ids">
              <a:documentation>List of boundary ids that are aliased</a:documentation>
              <ref name="integer_vector"/>
            </element>
            <element name="coordinate_map">
              <a:documentation>Python code which takes coordinate of an aliased boundary node and returns the coordinate of a physical boundary node</a:documentation>
              <ref name="python_code"/>
            </element>
          </element>
        </optional>
      </element>
    </choice>
  </define>
  <define name="linear_solver_options">
    <choice>
      <a:documentation>Iterative (Krylov) method to solve the linear discretised equation
Given are the most frequently used methods. The solution is done
by the PETSc library. Many more methods are provided.
</a:documentation>
      <element name="iterative_method">
        <a:documentation>Conjugate gradient method
Only works for symmetric systems.</a:documentation>
        <attribute name="name">
          <value>cg</value>
        </attribute>
      </element>
      <element name="iterative_method">
        <a:documentation>GMRES
Your safest bet for non-symmetric systems.</a:documentation>
        <attribute name="name">
          <value>gmres</value>
        </attribute>
        <element name="restart">
          <a:documentation>Restart value for gmres iteration
Higher values give better convergence but require more memory.
Suggested value: 30</a:documentation>
          <ref name="integer"/>
        </element>
      </element>
      <element name="iterative_method">
        <a:documentation>Direct method
This is for non-iterative methods
Only makes sense in combination with preconditioners that do a complete solve, e.g. lu.</a:documentation>
        <attribute name="name">
          <value>preonly</value>
        </attribute>
      </element>
      <element name="iterative_method">
        <a:documentation>Richardson iteration
Only apply preconditioner each iteration, no krylov acceleration</a:documentation>
        <attribute name="name">
          <value>richardson</value>
        </attribute>
      </element>
      <element name="iterative_method">
        <a:documentation>Other methods
Any method provided by the PETSc library
http://www-unix.mcs.anl.gov/petsc/petsc-2/snapshots/petsc-dev/docs/manualpages/KSP/KSPType.html
(available methods may depend on the PETSc library installed on your system)</a:documentation>
        <attribute name="name">
          <data type="string"/>
        </attribute>
      </element>
    </choice>
    <choice>
      <a:documentation>Preconditioner to be used in combination with the iterative method.</a:documentation>
      <element name="preconditioner">
        <a:documentation>Succesive Over-Relaxation
This includes SSOR (symmetric sor)</a:documentation>
        <attribute name="name">
          <value>sor</value>
        </attribute>
      </element>
      <element name="preconditioner">
        <a:documentation>The Eisenstat method
This preconditioner is equivalent to SOR but only uses half the number of flops,
i.e. same convergence rate but twice as fast per iteration. Because it computes
a different preconditioned residual the convergence in practice may be quite different though.
It does not work in parallel!</a:documentation>
        <attribute name="name">
          <value>eisenstat</value>
        </attribute>
      </element>
      <element name="preconditioner">
        <a:documentation>Incomplete LU decomposition</a:documentation>
        <attribute name="name">
          <value>ilu</value>
        </attribute>
      </element>
      <element name="preconditioner">
        <a:documentation>LU direct solver
This performs a complete, direct solve of the equation and should only be used in combination with preonly as iterative method.</a:documentation>
        <attribute name="name">
          <value>lu</value>
        </attribute>
      </element>
      <element name="preconditioner">
        <a:documentation>Fluidity's own multigrid method
Especially suited for ill-conditioned, large aspect ratio problems.
Currently does not work in parallel.</a:documentation>
        <attribute name="name">
          <value>mg</value>
        </attribute>
      </element>
      <element name="preconditioner">
        <a:documentation>Prometheus multigrid method</a:documentation>
        <attribute name="name">
          <value>prometheus</value>
        </attribute>
      </element>
      <element name="preconditioner">
        <a:documentation>Hypre preconditioners (includes boomeramg)</a:documentation>
        <attribute name="name">
          <value>hypre</value>
        </attribute>
        <choice>
          <element name="hypre_type">
            <a:documentation>BoomerAMG multigrid method</a:documentation>
            <attribute name="name">
              <value>boomeramg</value>
            </attribute>
          </element>
          <element name="hypre_type">
            <a:documentation>Other Hypre preconditioners</a:documentation>
            <attribute name="name">
              <data type="string" datatypeLibrary=""/>
            </attribute>
          </element>
        </choice>
      </element>
      <element name="preconditioner">
        <a:documentation>Other preconditioners
Any preconditioner provided by the PETSc library
http://www-unix.mcs.anl.gov/petsc/petsc-2/snapshots/petsc-dev/docs/manualpages/PC/PCType.html
(available preconditiors may depend on the PETSc library installed on your system)</a:documentation>
        <attribute name="name">
          <data type="string" datatypeLibrary=""/>
        </attribute>
      </element>
    </choice>
    <element name="relative_error">
      <a:documentation>Relative error
The solver finishes if the preconditioned error becomes smaller than the original preconditioned error times this value.
Suggested value: 1.0e-7</a:documentation>
      <ref name="real"/>
    </element>
    <optional>
      <element name="absolute_error">
        <a:documentation>Absolute error bound
The solver finishes if the preconditioned error becomes smaller than this value.</a:documentation>
        <ref name="real"/>
      </element>
    </optional>
    <element name="max_iterations">
      <a:documentation>Maximum number of iterations allowed in the linear solver
before giving up.</a:documentation>
      <ref name="integer"/>
    </element>
    <optional>
      <element name="start_from_zero">
        <a:documentation>Switch on to not use an initial guess from a previous solve but
start with a zero vector. Note that some of the solves always
start at zero in which case this switch will have no effect (see the log output).</a:documentation>
        <empty/>
      </element>
    </optional>
    <optional>
      <element name="petsc_options">
        <a:documentation>Miscellaneous PETSc options
Any options not included above can be set using the PETSc option syntax
For example: -ksp_dtol 1e5 -ksp_monitor_draw</a:documentation>
        <data type="string" datatypeLibrary=""/>
      </element>
    </optional>
  </define>
  <define name="solver_choice">
    <element name="string_value">
      <!--
        Lines is a hint to the gui about the size of the text box.
        It is not an enforced limit on string length.
      -->
      <attribute name="lines">
        <value>1</value>
      </attribute>
      <choice>
        <value>cg</value>
        <value>gmres</value>
        <data type="string"/>
      </choice>
    </element>
    <ref name="comment"/>
  </define>
  <define name="input_choice_tensor_field">
    <choice>
      <element name="isotropic">
        <ref name="input_choice_real"/>
      </element>
      <element name="anisotropic_symmetric">
        <ref name="input_choice_real_dim_symmetric_tensor"/>
      </element>
      <element name="anisotopic_asymmetric">
        <ref name="input_choice_real_dim_tensor"/>
      </element>
    </choice>
  </define>
  <define name="constitutive_laws">
    <choice>
      <element name="constitutive_law">
        <a:documentation>Constitutive laws for fluids</a:documentation>
        <attribute name="name">
          <value>fluid</value>
        </attribute>
      </element>
      <element name="constitutive_law">
        <a:documentation>Constitutive laws for solids</a:documentation>
        <attribute name="name">
          <value>solid</value>
        </attribute>
      </element>
      <element name="constitutive_law">
        <attribute name="name">
          <value>mixture</value>
        </attribute>
        <optional>
          <choice>
            <element name="flow_regime_solid_spheres">
              <a:documentation>if off replaces MPHAOP(2,1) = 0</a:documentation>
              <attribute name="replaces">
                <value>MPHAOP(2,1)=1</value>
              </attribute>
            </element>
            <element name="flow_regime_tubulent_viscosity">
              <a:documentation>if off replaces MPHAOP(2,1) = 0</a:documentation>
              <attribute name="replaces">
                <value>MPHAOP(2,1)=-1</value>
              </attribute>
            </element>
          </choice>
        </optional>
        <optional>
          <element name="permeability">
            <attribute name="replaces">
              <value>PERCO1 PERCO2 PERCO3 PERCO4</value>
            </attribute>
            <element name="maximum">
              <attribute name="replaces">
                <value>PERCO1</value>
              </attribute>
              <ref name="real"/>
            </element>
            <element name="minimum">
              <attribute name="replaces">
                <value>PERCO2</value>
              </attribute>
              <ref name="real"/>
            </element>
            <element name="width">
              <attribute name="replaces">
                <value>PERCO3</value>
              </attribute>
              <ref name="real"/>
            </element>
            <element name="target">
              <attribute name="replaces">
                <value>PERCO4</value>
              </attribute>
              <ref name="real"/>
            </element>
          </element>
        </optional>
        <optional>
          <element name="drag">
            <a:documentation>if off replaces PHAMOD(1) = 0, MPHAOP(2,2) = 0</a:documentation>
            <attribute name="replaces">
              <value>PHAMOD(1) MPHAOP(2,2)</value>
            </attribute>
            <optional>
              <choice>
                <element name="sphere_inside_solid">
                  <a:documentation>if off replaces PHAMOD(1) = 0</a:documentation>
                  <attribute name="replaces">
                    <value>PHAMOD(1) = 3</value>
                  </attribute>
                </element>
                <element name="sphere_in_fluidised_beds">
                  <a:documentation>if off replaces PHAMOD(1) = 0</a:documentation>
                  <attribute name="replaces">
                    <value>PHAMOD(1) = 4</value>
                  </attribute>
                </element>
                <element name="wen_yu_fluidised_beds">
                  <a:documentation>if off replaces PHAMOD(1) = 0</a:documentation>
                  <attribute name="replaces">
                    <value>PHAMOD(1) = 6</value>
                  </attribute>
                </element>
                <element name="richardson_zaki_syamlal">
                  <a:documentation>if off replaces PHAMOD(1) = 0</a:documentation>
                  <attribute name="replaces">
                    <value>PHAMOD(1) = 7</value>
                  </attribute>
                </element>
                <element name="wen_yu">
                  <a:documentation>if off replaces PHAMOD(1) = 0</a:documentation>
                  <attribute name="replaces">
                    <value>PHAMOD(1) = 8</value>
                  </attribute>
                </element>
              </choice>
            </optional>
            <optional>
              <choice>
                <element name="sworm_correction">
                  <a:documentation>if off replaces MPHAOP(2.2) = 0</a:documentation>
                  <attribute name="replaces">
                    <value>MPHAOP(2,2) = 1</value>
                  </attribute>
                </element>
                <element name="use_mixture_viscosity">
                  <a:documentation>if off replaces MPHAOP(2.2) = 0</a:documentation>
                  <attribute name="replaces">
                    <value>MPHAOP(2,2) = 2</value>
                  </attribute>
                </element>
              </choice>
            </optional>
            <optional>
              <element name="packing">
                <a:documentation>various maximum packing options</a:documentation>
                <element name="legacy_alfsta">
                  <attribute name="replaces">
                    <value>ALFSTA</value>
                  </attribute>
                  <ref name="real"/>
                </element>
                <element name="legacy_alfsta2">
                  <attribute name="replaces">
                    <value>ALFSTA2</value>
                  </attribute>
                  <ref name="real"/>
                </element>
                <element name="legacy_mixgo1">
                  <a:documentation>maximum packing associated with the multicomponents</a:documentation>
                  <attribute name="replaces">
                    <value>MIXGO1</value>
                  </attribute>
                  <ref name="real"/>
                </element>
              </element>
            </optional>
            <element name="collision_probability">
              <a:documentation>no idea what should go here... sorry</a:documentation>
              <empty/>
            </element>
          </element>
        </optional>
        <optional>
          <element name="particle_size">
            <empty/>
          </element>
        </optional>
        <optional>
          <element name="virtual_mass">
            <a:documentation>if off replaces PHAMOD(2) = 0</a:documentation>
            <attribute name="replaces">
              <value>PHAMOD(2)</value>
            </attribute>
            <ref name="integer"/>
          </element>
        </optional>
        <optional>
          <element name="particle_particle_restitution_coefficient">
            <attribute name="replaces">
              <value>RESCOE</value>
            </attribute>
            <ref name="real"/>
          </element>
        </optional>
        <optional>
          <element name="particle_wall_restitution_coefficient">
            <attribute name="replaces">
              <value>RESCOW</value>
            </attribute>
            <ref name="real"/>
          </element>
        </optional>
        <optional>
          <element name="wall_gas_viscosity">
            <attribute name="replaces">
              <value>MUWALL</value>
            </attribute>
            <ref name="real"/>
          </element>
        </optional>
        <optional>
          <element name="particle_shape">
            <a:documentation>no idea what should go here... sorry</a:documentation>
            <empty/>
          </element>
        </optional>
      </element>
    </choice>
  </define>
  <define name="region_ids">
    <optional>
      <element name="region_ids">
        <a:documentation>Optional region ids to associate different values
to different regions of the mesh.
Leave unselected if you're not using multiple regions or
region_ids.
Currently only works with triangle files created by gmsh2triangle.</a:documentation>
        <ref name="integer_vector"/>
      </element>
    </optional>
  </define>
  <define name="temporal_control_volume_options">
    <element name="control_volumes">
      <a:documentation>Temporal discretisation options that are only relevent if a control volume
spatial discretisation is selected for this field.</a:documentation>
      <optional>
        <element name="number_advection_iterations">
          <a:documentation>Number of iterations within an advection solve.
This increases the accuracy of the face values and ensures that
the pivoted solution is cancelled out.
Defaults to 1 if unselected.</a:documentation>
          <attribute name="replaces">
            <value>INT(ABS(NDISOT)/10)</value>
          </attribute>
          <ref name="integer"/>
          <optional>
            <element name="tolerance">
              <a:documentation>Cut short advection_iterations if the specified tolerance
is reached.
This currently only works for "pure" control volume equation
types (i.e. not AdvectionDiffusion)</a:documentation>
              <ref name="real"/>
            </element>
          </optional>
        </element>
      </optional>
      <optional>
        <choice>
          <element name="maximum_courant_number_per_subcycle">
            <a:documentation>***UNDER TESTING***
Use timestep subcycling to solve this equation.
Specify the maximum courant number per subcycle.
This currently only works for "pure" control volume equation
types (i.e. not AdvectionDiffusion)</a:documentation>
            <ref name="real"/>
            <choice>
              <element name="courant_number">
                <a:documentation>***UNDER TESTING***
Select the Courant Number definition to be used
when subcycling
This uses the control volume definition of the CFL Number.</a:documentation>
                <attribute name="name">
                  <value>ControlVolumeCFLNumber</value>
                </attribute>
                <empty/>
              </element>
              <element name="courant_number">
                <a:documentation>***UNDER TESTING***
Select the Courant Number definition to be used
when subcycling.
This uses the finite element definition of the CFL Number.</a:documentation>
                <attribute name="name">
                  <value>CFLNumber</value>
                </attribute>
                <empty/>
              </element>
              <element name="courant_number">
                <a:documentation>***UNDER TESTING***
Select the Courant Number definition to be used 
when subcycling.</a:documentation>
                <attribute name="name">
                  <data type="string" datatypeLibrary=""/>
                </attribute>
                <empty/>
              </element>
            </choice>
          </element>
          <element name="number_advection_subcycles">
            <a:documentation>***UNDER TESTING***
Use timestep subcycling to solve this equation.
Specify the number of subcycles.
This currently only works for "pure" control volume equation
types (i.e. not AdvectionDiffusion).</a:documentation>
            <ref name="integer"/>
          </element>
        </choice>
      </optional>
      <optional>
        <element name="limit_theta">
          <a:documentation>Only works if a control volume spatial discretisation is selected.
If unactivated then theta specified will be used.
Otherwise use variable limited theta on individual faces.</a:documentation>
          <attribute name="replaces">
            <value>MOD(INT(ABS(NDISOT)/1),10) = 1,3,5,7,9 (odd)</value>
          </attribute>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="pivot_theta">
          <a:documentation>Only works if a control volume spatial discretisation is selected.
Time discretisation of upwind discretisation off which the
higher order solution is pivotted.
 - pivot_theta = 1 - implicit pivot (default if not set and 
                     best choice if not intentionally modifying
                     scheme to be explicit)
 - pivot_theta = 0 - explicit pivot</a:documentation>
          <ref name="real"/>
        </element>
      </optional>
      <optional>
        <element name="conservative_theta">
          <a:documentation>Only works if a control volume spatial discretisation is selected.
Time discretisation of conservative term.
Only has an effect if conservative_advection != 1
 - conservative_theta = 1 - implicit (default if not set and 
                     best choice if not intentionally modifying
                     scheme to be explicit)
 - conservative_theta = 0 - explicit</a:documentation>
          <ref name="real"/>
        </element>
      </optional>
      <optional>
        <element name="assume_explicit">
          <a:documentation>Assume the lumped mass matrix is the only contribution to the
left hand side and skip the solver and lhs assembly calls altogether.
THIS WILL NOT WORK WITH DIRICHLET BOUNDARY CONDITIONS!</a:documentation>
          <ref name="comment"/>
        </element>
      </optional>
    </element>
  </define>
  <define name="spatial_control_volume_options">
    <element name="control_volumes">
      <a:documentation>Use a control volume discretisation</a:documentation>
      <attribute name="replaces">
        <value>NDISOT &gt;= 10, DISOTT = -7, TLUMP = .TRUE.</value>
      </attribute>
      <choice>
        <a:documentation>Type of control volume discretisation to use</a:documentation>
        <element name="face_value">
          <a:documentation>First Order Upwind face value discretisation
face_value = donor_value, where
donor_value = income*val_1 + (1.-income)*val_2, where
val_i is the value on the ith node neighbouring the face and
income = [0, 1] depending on whether the flow is coming from node 1 or 2
First order upwinding is monotonic so no limiting is ever required</a:documentation>
          <attribute name="name">
            <value>FirstOrderUpwind</value>
          </attribute>
          <attribute name="replaces">
            <value>MOD(INT(ABS(NDISOT)/1),10) = 0,1</value>
          </attribute>
          <empty/>
        </element>
        <element name="face_value">
          <a:documentation>Trapezoidal face value discretisation
face_value = 0.5*(val_1 + val_2), where
val_i is the value on the ith node neighbouring the face</a:documentation>
          <attribute name="name">
            <value>Trapezoidal</value>
          </attribute>
          <attribute name="replaces">
            <value>MOD(INT(ABS(NDISOT)/1),10) = 2,3</value>
          </attribute>
          <element name="limit_face_value">
            <a:documentation>Trapezoidal discretisation is unbounded so limiting is compulsory</a:documentation>
            <attribute name="replaces">
              <value>MOD(INT(ABS(NDISOT)/1),10) = 2,3</value>
            </attribute>
            <optional>
              <element name="slopes">
                <a:documentation>Control the upper and lower slopes of the NVD limiter</a:documentation>
                <optional>
                  <element name="lower">
                    <a:documentation>Defaults to Sweby, 1984 limiter (= 1.0) if unselected</a:documentation>
                    <ref name="real"/>
                  </element>
                </optional>
                <optional>
                  <element name="upper">
                    <a:documentation>Defaults to Sweby, 1984 limiter (= 2.0) if unselected</a:documentation>
                    <ref name="real"/>
                  </element>
                </optional>
              </element>
            </optional>
            <optional>
              <choice>
                <element name="project_upwind_value">
                  <a:documentation>Otherwise known as anisotropic limiting.
This is only currently available on simplex meshes.
Projects the value of the advected variable from that found 
in the element upwind of the node pair straddling the face.</a:documentation>
                  <attribute name="replaces">
                    <value>NDISOT &gt; 0 on simplex meshes</value>
                  </attribute>
                  <optional>
                    <element name="reflect_off_domain_boundaries">
                      <a:documentation>When the donor node is on a domain boundary reflect the projection
back into the mesh.</a:documentation>
                      <empty/>
                    </element>
                  </optional>
                  <optional>
                    <element name="bound_projected_value_locally">
                      <a:documentation>Constrain the projected value to be between the min and max of the
element values which it was found from.</a:documentation>
                      <empty/>
                    </element>
                  </optional>
                  <optional>
                    <element name="store_upwind_elements">
                      <a:documentation>Store the locations of the elements where the upwind values
are projected from for each node pair.
This inserts an integer csr matrix into state so is memory expensive but
saves a significant amount of time (searching around the neighbouring elements).
This is unsafe for moving meshes but should be ok for adaptive meshes.</a:documentation>
                      <attribute name="replaces">
                        <value>ABS(NDISOT) &gt;= 1000</value>
                      </attribute>
                      <optional>
                        <element name="store_upwind_quadrature">
                          <a:documentation>Store the quadrature locations within the elements where the upwind values
are projected from for each node pair.
This inserts a real block csr matrix into state so is even more memory
expensive than just storing the upwind elements and only saves a comparitively
marginal amount of time (as actually searching the neighbouring elements is the
slowest bit, finding the quadrature is relatively easy).</a:documentation>
                          <attribute name="replaces">
                            <value>ABS(NDISOT) &gt;= 1000</value>
                          </attribute>
                          <empty/>
                        </element>
                      </optional>
                    </element>
                  </optional>
                </element>
                <element name="locally_bound_upwind_value">
                  <a:documentation>Otherwise known as isotropic limiting.
This is available on all meshes.
Chooses an upwind value by selecting the maximum or minimum of the neighbouring
nodes depending on the local slope of the donor and downwind values.</a:documentation>
                  <attribute name="replaces">
                    <value>all cube elements, NDISOT &lt; 0 on simplex elements</value>
                  </attribute>
                  <empty/>
                </element>
              </choice>
            </optional>
          </element>
        </element>
        <element name="face_value">
          <a:documentation>Finite Element face value discretisation
face_value = finite element interpolation from surrounding nodes</a:documentation>
          <attribute name="name">
            <value>FiniteElement</value>
          </attribute>
          <attribute name="replaces">
            <value>MOD(INT(ABS(NDISOT)/1),10) = 4,5,6,7</value>
          </attribute>
          <optional>
            <element name="limit_face_value">
              <a:documentation>Finite element discretisation may become unbounded so limiting is often necessary.</a:documentation>
              <attribute name="replaces">
                <value>MOD(INT(ABS(NDISOT)/1),10) = 4,5</value>
              </attribute>
              <optional>
                <element name="slopes">
                  <a:documentation>Control the upper and lower slopes of the NVD limiter</a:documentation>
                  <optional>
                    <element name="lower">
                      <a:documentation>Defaults to Sweby, 1984 limiter (= 1.0) if unselected</a:documentation>
                      <ref name="real"/>
                    </element>
                  </optional>
                  <optional>
                    <element name="upper">
                      <a:documentation>Defaults to Sweby, 1984 limiter (= 2.0) if unselected</a:documentation>
                      <ref name="real"/>
                    </element>
                  </optional>
                </element>
              </optional>
              <optional>
                <choice>
                  <element name="project_upwind_value">
                    <a:documentation>Otherwise known as anisotropic limiting.
This is only currently available on simplex meshes.
Projects the value of the advected variable from that found 
in the element upwind of the node pair straddling the face.</a:documentation>
                    <attribute name="replaces">
                      <value>NDISOT &gt; 0 on simplex meshes</value>
                    </attribute>
                    <optional>
                      <element name="reflect_off_domain_boundaries">
                        <a:documentation>When the donor node is on a domain boundary reflect the projection
back into the mesh.</a:documentation>
                        <empty/>
                      </element>
                    </optional>
                    <optional>
                      <element name="bound_projected_value_locally">
                        <a:documentation>Constrain the projected value to be between the min and max of the
element values which it was found from.</a:documentation>
                        <empty/>
                      </element>
                    </optional>
                    <optional>
                      <element name="store_upwind_elements">
                        <a:documentation>Store the locations of the elements where the upwind values
are projected from for each node pair.
This inserts an integer csr matrix into state so is memory expensive but
saves a significant amount of time (searching around the neighbouring elements).
This is unsafe for moving meshes but should be ok for adaptive meshes.</a:documentation>
                        <attribute name="replaces">
                          <value>ABS(NDISOT) &gt;= 1000</value>
                        </attribute>
                        <optional>
                          <element name="store_upwind_quadrature">
                            <a:documentation>Store the quadrature locations within the elements where the upwind values
are projected from for each node pair.
This inserts a real block csr matrix into state so is even more memory
expensive than just storing the upwind elements and only saves a comparitively
marginal amount of time (as actually searching the neighbouring elements is the
slowest bit, finding the quadrature is relatively easy).</a:documentation>
                            <attribute name="replaces">
                              <value>ABS(NDISOT) &gt;= 1000</value>
                            </attribute>
                            <empty/>
                          </element>
                        </optional>
                      </element>
                    </optional>
                  </element>
                  <element name="locally_bound_upwind_value">
                    <a:documentation>Otherwise known as isotropic limiting.
This is available on all meshes.
Chooses an upwind value by selecting the maximum or minimum of the neighbouring
nodes depending on the local slope of the donor and downwind values.</a:documentation>
                    <attribute name="replaces">
                      <value>all cube elements, NDISOT &lt; 0 on simplex elements</value>
                    </attribute>
                    <empty/>
                  </element>
                </choice>
              </optional>
            </element>
          </optional>
        </element>
        <element name="face_value">
          <a:documentation>HyperC face value discretisation
face_value calculated from upper bound of explicit TVD zone of NVD diagram
Normally used for MaterialVolumeFraction fields</a:documentation>
          <attribute name="name">
            <value>HyperC</value>
          </attribute>
          <attribute name="replaces">
            <value>MOD(INT(ABS(NDISOT)/1),10) = 8,9</value>
          </attribute>
          <optional>
            <choice>
              <element name="project_upwind_value">
                <a:documentation>Otherwise known as anisotropic limiting (although when used with HyperC this
is not strictly speaking limiting).
This is only currently available on simplex meshes.
Projects the value of the advected variable from that found 
in the element upwind of the node pair straddling the face.</a:documentation>
                <attribute name="replaces">
                  <value>NDISOT &gt; 0 on simplex meshes</value>
                </attribute>
                <optional>
                  <element name="reflect_off_domain_boundaries">
                    <a:documentation>When the donor node is on a domain boundary reflect the projection
back into the mesh.</a:documentation>
                    <attribute name="replaces">
                      <value>MOD(INT(ABS(NDISOT)/1),10) = 8,9</value>
                    </attribute>
                    <empty/>
                  </element>
                </optional>
                <optional>
                  <element name="bound_projected_value_locally">
                    <a:documentation>Constrain the projected value to be between the min and max of the
element values which it was found from.</a:documentation>
                    <attribute name="replaces">
                      <value>MOD(INT(ABS(NDISOT)/1),10) = 8,9</value>
                    </attribute>
                    <empty/>
                  </element>
                </optional>
                <optional>
                  <element name="store_upwind_elements">
                    <a:documentation>Store the locations of the elements where the upwind values
are projected from for each node pair.
This inserts an integer csr matrix into state so is memory expensive but
saves a significant amount of time (searching around the neighbouring elements).
This is unsafe for moving meshes but should be ok for adaptive meshes.</a:documentation>
                    <attribute name="replaces">
                      <value>ABS(NDISOT) &gt;= 1000</value>
                    </attribute>
                    <optional>
                      <element name="store_upwind_quadrature">
                        <a:documentation>Store the quadrature locations within the elements where the upwind values
are projected from for each node pair.
This inserts a real block csr matrix into state so is even more memory
expensive than just storing the upwind elements and only saves a comparitively
marginal amount of time (as actually searching the neighbouring elements is the
slowest bit, finding the quadrature is relatively easy).</a:documentation>
                        <attribute name="replaces">
                          <value>ABS(NDISOT) &gt;= 1000</value>
                        </attribute>
                        <empty/>
                      </element>
                    </optional>
                  </element>
                </optional>
              </element>
              <element name="locally_bound_upwind_value">
                <a:documentation>Otherwise known as isotropic limiting (although when used with HyperC this
is not strictly speaking limiting).
This is available on all meshes.
Chooses an upwind value by selecting the maximum or minimum of the neighbouring
nodes depending on the local slope of the donor and downwind values.</a:documentation>
                <attribute name="replaces">
                  <value>all cube elements, NDISOT &lt; 0 on simplex elements</value>
                </attribute>
                <empty/>
              </element>
            </choice>
          </optional>
          <choice>
            <element name="courant_number">
              <a:documentation>Select the Courant Number definition to be used in the slope of
the NVD diagram upper bound.
This uses the finite difference definition of the CFL Number
consistent with the 1D version of HyperC (Leonard, 1981).
This is the default that reproduces old behaviour.
All others are under testing or construction.</a:documentation>
              <attribute name="name">
                <value>FiniteDifferenceCFLNumber</value>
              </attribute>
              <empty/>
            </element>
            <element name="courant_number">
              <a:documentation>***UNDER TESTING***
Select the Courant Number definition to be used in the slope of
the NVD diagram upper bound.
This uses the control volume definition of the CFL Number.</a:documentation>
              <attribute name="name">
                <value>ControlVolumeCFLNumber</value>
              </attribute>
              <empty/>
            </element>
            <element name="courant_number">
              <a:documentation>***UNDER TESTING***
Select the Courant Number definition to be used in the slope of
the NVD diagram upper bound.
This uses the finite element definition of the CFL Number.</a:documentation>
              <attribute name="name">
                <value>CFLNumber</value>
              </attribute>
              <empty/>
            </element>
            <element name="courant_number">
              <a:documentation>***UNDER TESTING***
Select the Courant Number definition to be used in the slope of
the NVD diagram upper bound.</a:documentation>
              <attribute name="name">
                <data type="string" datatypeLibrary=""/>
              </attribute>
              <empty/>
            </element>
          </choice>
        </element>
        <element name="face_value">
          <a:documentation>UltraC face value discretisation
face_value calculated from extended upper bound of explicit TVD zone of NVD diagram assuming
values bounded by 0 and 1 (i.e. not useful for non MaterialVolumeFraction fields).</a:documentation>
          <attribute name="name">
            <value>UltraC</value>
          </attribute>
          <attribute name="replaces">
            <value>MOD(INT(ABS(NDISOT)/1),10) = 8,9, with ULTRAC = TRUE from solidity_options.inp</value>
          </attribute>
          <optional>
            <choice>
              <element name="project_upwind_value">
                <a:documentation>Otherwise known as anisotropic limiting (although when used with UltraC this
is not strictly speaking limiting).
This is only currently available on simplex meshes.
Projects the value of the advected variable from that found 
in the element upwind of the node pair straddling the face.</a:documentation>
                <attribute name="replaces">
                  <value>NDISOT &gt; 0 on simplex meshes</value>
                </attribute>
                <optional>
                  <element name="reflect_off_domain_boundaries">
                    <a:documentation>When the donor node is on a domain boundary reflect the projection
back into the mesh.</a:documentation>
                    <empty/>
                  </element>
                </optional>
                <optional>
                  <element name="bound_projected_value_locally">
                    <a:documentation>Constrain the projected value to be between the min and max of the
element values which it was found from.</a:documentation>
                    <empty/>
                  </element>
                </optional>
                <optional>
                  <element name="store_upwind_elements">
                    <a:documentation>Store the locations of the elements where the upwind values
are projected from for each node pair.
This inserts an integer csr matrix into state so is memory expensive but
saves a significant amount of time (searching around the neighbouring elements).
This is unsafe for moving meshes but should be ok for adaptive meshes.</a:documentation>
                    <attribute name="replaces">
                      <value>ABS(NDISOT) &gt;= 1000</value>
                    </attribute>
                    <optional>
                      <element name="store_upwind_quadrature">
                        <a:documentation>Store the quadrature locations within the elements where the upwind values
are projected from for each node pair.
This inserts a real block csr matrix into state so is even more memory
expensive than just storing the upwind elements and only saves a comparitively
marginal amount of time (as actually searching the neighbouring elements is the
slowest bit, finding the quadrature is relatively easy).</a:documentation>
                        <attribute name="replaces">
                          <value>ABS(NDISOT) &gt;= 1000</value>
                        </attribute>
                        <empty/>
                      </element>
                    </optional>
                  </element>
                </optional>
              </element>
              <element name="locally_bound_upwind_value">
                <a:documentation>Otherwise known as isotropic limiting (although when used with UltraC this
is not strictly speaking limiting).
This is available on all meshes.
Chooses an upwind value by selecting the maximum or minimum of the neighbouring
nodes depending on the local slope of the donor and downwind values.</a:documentation>
                <attribute name="replaces">
                  <value>all cube elements, NDISOT &lt; 0 on simplex elements</value>
                </attribute>
                <empty/>
              </element>
            </choice>
          </optional>
          <choice>
            <element name="courant_number">
              <a:documentation>Select the Courant Number definition to be used in the slope of
the NVD diagram upper bound.
This uses the finite difference definition of the CFL Number
consistent with the 1D version of HyperC (Leonard, 1981).
This is the default that reproduces old behaviour.
All others are under testing or construction.</a:documentation>
              <attribute name="name">
                <value>FiniteDifferenceCFLNumber</value>
              </attribute>
              <empty/>
            </element>
            <element name="courant_number">
              <a:documentation>***UNDER TESTING***
Select the Courant Number definition to be used in the slope of
the NVD diagram upper bound.
This uses the control volume definition of the CFL Number.</a:documentation>
              <attribute name="name">
                <value>ControlVolumeCFLNumber</value>
              </attribute>
              <empty/>
            </element>
            <element name="courant_number">
              <a:documentation>***UNDER TESTING***
Select the Courant Number definition to be used in the slope of
the NVD diagram upper bound.
This uses the finite element definition of the CFL Number.</a:documentation>
              <attribute name="name">
                <value>CFLNumber</value>
              </attribute>
              <empty/>
            </element>
            <element name="courant_number">
              <a:documentation>***UNDER TESTING***
Select the Courant Number definition to be used in the slope of
the NVD diagram upper bound.</a:documentation>
              <attribute name="name">
                <data type="string" datatypeLibrary=""/>
              </attribute>
              <empty/>
            </element>
          </choice>
        </element>
      </choice>
      <optional>
        <element name="integrate_domain_boundaries">
          <a:documentation>Domain boundaries are control volume surfaces too!
So if there's any flow going through them it's necessary to
integrate over them too.</a:documentation>
          <attribute name="replaces">
            <value>CVSURF from solidity_options.inp</value>
          </attribute>
          <empty/>
        </element>
      </optional>
      <optional>
        <element name="legacy_disott">
          <a:documentation>Allows legacy options to be set.
BE WARNED: this probably means you're using inconsistent discretisations
on different terms - make sure you're happy with what your code path is doing
before selecting this.</a:documentation>
          <attribute name="replaces">
            <value>DISOTT</value>
          </attribute>
          <ref name="integer"/>
        </element>
      </optional>
    </element>
  </define>
  <define name="copied_field_options">
    <attribute name="copy_from_field">
      <data type="string" datatypeLibrary=""/>
    </attribute>
  </define>
  <!--
    Select the type of dynamic control to be used
    Note: DEM and FEMDEM require the respective libraries
    to be compiled.
  -->
  <define name="input_solid_dynamics_cylinders">
    <choice>
      <element name="static_type">
        <a:documentation>First line of file is free to use (for comments)
Second line must contain the number of particles
Third and fourth line are again for comments.
Following lines include 4 columns, corresponding to 
the particle's x, y, and z positions, followed by the radius.</a:documentation>
        <attribute name="name">
          <value>from_input_file</value>
        </attribute>
        <attribute name="file_name">
          <data type="string"/>
        </attribute>
      </element>
      <element name="static_type">
        <a:documentation>Two python scripts must be provided. The script is cycled over each particle.
One script for particle position (output is tuple of position coords)
Second script is for particle radius (output is tuple of position coords)
Python functions should be of the form:
def val(X, t):
  Function code
  return # Return value
  where X is a tuple of length geometry dimension.
  X[0] contains the number of the particle (in real format)</a:documentation>
        <attribute name="name">
          <value>python_script</value>
        </attribute>
        <element name="number_of_particles">
          <ref name="integer"/>
        </element>
        <element name="position_script">
          <ref name="python_code"/>
        </element>
        <element name="radius_script">
          <ref name="python_code"/>
        </element>
      </element>
      <element name="dynamic_type">
        <a:documentation>Obtain values from point and radius file.
First line of file is free to use (for comments)
Second line must contain the number of particles
Third and fourth line are again for comments. 
Following lines include 10 columns, corresponding to 
the particle's x, y, and z positions, followed by the radius, then
velocities in x, y, and z directions, followed by angular velocities
in the x, y, and z directions.</a:documentation>
        <attribute name="name">
          <value>from_input_file</value>
        </attribute>
        <attribute name="file_name">
          <data type="string"/>
        </attribute>
      </element>
      <element name="dynamic_type">
        <a:documentation>Two python scripts must be provided. The script is cycled over each particle.
One script for particle position (output is tuple of position coords)
Second script is for particle radius (output is tuple of position coords)
Third script is for particle translational velocity.
Fourth script is for particle angular velocity. (Note: particles 
have a no slip boundary condition at the surface, so this angular velocity
WILL matter to the flow.)
Python functions should be of the form:
def val(X, t):
  Function code
  return # Return value
where X is a tuple of length geometry dimension.
  X[0] contains the number of the particle (in real format)</a:documentation>
        <attribute name="name">
          <value>python_script</value>
        </attribute>
        <element name="number_of_particles">
          <ref name="integer"/>
        </element>
        <element name="position_script">
          <ref name="python_code"/>
        </element>
        <element name="radius_script">
          <ref name="python_code"/>
        </element>
        <element name="translation_velocity_script">
          <ref name="python_code"/>
        </element>
        <element name="angular_velocity_script">
          <ref name="python_code"/>
        </element>
      </element>
    </choice>
  </define>
  <!--
    Select the type of dynamic control to be used
    Note: DEM and FEMDEM require the respective libraries
    to be compiled.
  -->
  <define name="input_solid_dynamics_spheres">
    <choice>
      <element name="static_type">
        <a:documentation>Obtain values from input file.
First line of file is free to use (for comments)
Second line must contain the number of particles
Third and fourth line are again for comments.
Following lines include 4 columns, corresponding to 
the particle's x, y, and z positions, followed by the radius.</a:documentation>
        <attribute name="name">
          <value>from_input_file</value>
        </attribute>
        <attribute name="file_name">
          <data type="string"/>
        </attribute>
      </element>
      <element name="static_type">
        <a:documentation>Two python scripts must be provided. The script is cycled over each particle.
One script for particle position (output is radius value)
Second script is for particle radius (output is tuple of position coords)
Python functions should be of the form:
def val(X, t):
  Function code
  return # Return value
where X is a tuple of length geometry dimension.
  X[0] contains the number of the particle (in real format)</a:documentation>
        <attribute name="name">
          <value>python_script</value>
        </attribute>
        <element name="number_of_particles">
          <ref name="integer"/>
        </element>
        <element name="position_script">
          <ref name="python_code"/>
        </element>
        <element name="radius_script">
          <ref name="python_code"/>
        </element>
      </element>
      <element name="dynamic_type">
        <a:documentation>Obtain values from input file.
First line of file is free to use (for comments)
Second line must contain the number of particles
Third and fourth line are again for comments. 
Following lines include 10 columns, corresponding to 
the particle's x, y, and z positions, followed by the radius, then
velocities in x, y, and z directions, followed by angular velocities
in the x, y, and z directions.</a:documentation>
        <attribute name="name">
          <value>from_input_file</value>
        </attribute>
        <attribute name="file_name">
          <data type="string"/>
        </attribute>
      </element>
      <element name="dynamic_type">
        <a:documentation>Two python scripts must be provided. The script is cycled over each particle.
One script for particle position (output is tuple of position coords)
Second script is for particle radius (output is radius value)
Third script is for particle translational velocity.
Fourth script is for particle angular velocity. (Note: particles 
have a no slip boundary condition at the surface, so this angular velocity
WILL matter to the flow.)
Python functions should be of the form:
def val(X, t):
  Function code
  return # Return value
where X is a tuple of length geometry dimension.
  X[0] contains the number of the particle (in real format)</a:documentation>
        <attribute name="name">
          <value>python_script</value>
        </attribute>
        <element name="number_of_particles">
          <ref name="integer"/>
        </element>
        <element name="position_script">
          <ref name="python_code"/>
        </element>
        <element name="radius_script">
          <ref name="python_code"/>
        </element>
        <element name="translation_velocity_script">
          <ref name="python_code"/>
        </element>
        <element name="angular_velocity_script">
          <ref name="python_code"/>
        </element>
      </element>
      <element name="dynamic_type">
        <a:documentation>Using y3D to model dynamics. Filename of input file for y3D must
be specified.</a:documentation>
        <attribute name="name">
          <value>use_y3D</value>
        </attribute>
        <attribute name="file_name">
          <data type="string"/>
        </attribute>
        <optional>
          <element name="oneway">
            <empty/>
          </element>
        </optional>
      </element>
    </choice>
  </define>
  <!--
    Select the type of dynamic control to be used
    Note: DEM and FEMDEM require the respective libraries
    to be compiled.
  -->
  <define name="input_solid_dynamics_ext_mesh2D">
    <choice>
      <element name="static_type">
        <a:documentation>Obtain values from input file.
First line of file is free to use (for comments)
Second line must contain the number of particles
Third and fourth line are again for comments.
Following lines include 4 columns, corresponding to 
the particle's x, y, and z positions, followed by an initial angle
of rotation.</a:documentation>
        <attribute name="name">
          <value>from_input_file</value>
        </attribute>
        <attribute name="file_name">
          <data type="string"/>
        </attribute>
        <element name="geometry_file">
          <attribute name="name">
            <value>gid_mesh2D</value>
          </attribute>
          <attribute name="file_name">
            <data type="string"/>
          </attribute>
          <attribute name="format">
            <value>GiD_2D</value>
          </attribute>
          <attribute name="max_nodes">
            <data type="integer"/>
          </attribute>
          <attribute name="max_elements">
            <data type="integer"/>
          </attribute>
          <ref name="comment"/>
        </element>
      </element>
      <element name="static_type">
        <a:documentation>Two python scripts must be provided. The script is cycled over each particle.
One script for particle position (output is tuple of position coords)
The second script sets particle angular position (with respect to original reference)
Python functions should be of the form:
def val(X, t):
  Function code
  return # Return value
where X is a tuple of length geometry dimension.
  X[0] contains the number of the particle (in real format)</a:documentation>
        <attribute name="name">
          <value>python_script</value>
        </attribute>
        <element name="geometry_file">
          <attribute name="name">
            <value>gid_mesh2D</value>
          </attribute>
          <attribute name="file_name">
            <data type="string"/>
          </attribute>
          <attribute name="format">
            <value>GiD_2D</value>
          </attribute>
          <attribute name="max_nodes">
            <data type="integer"/>
          </attribute>
          <attribute name="max_elements">
            <data type="integer"/>
          </attribute>
          <ref name="comment"/>
        </element>
        <element name="number_of_particles">
          <ref name="integer"/>
        </element>
        <element name="position_script">
          <ref name="python_code"/>
        </element>
        <element name="angular_position_script">
          <ref name="python_code"/>
        </element>
      </element>
      <element name="dynamic_type">
        <a:documentation>Obtain values from input file.
First line of file is free to use (for comments)
Second line must contain the number of particles
Third and fourth line are again for comments. 
Following lines include 5 columns, corresponding to 
the particle's x, y, and z positions, angular position,
followed by the z component of angular velocity</a:documentation>
        <attribute name="name">
          <value>from_input_file</value>
        </attribute>
        <attribute name="file_name">
          <data type="string"/>
        </attribute>
        <element name="geometry_file">
          <attribute name="name">
            <value>gid_mesh2D</value>
          </attribute>
          <attribute name="file_name">
            <data type="string"/>
          </attribute>
          <attribute name="format">
            <value>GiD_2D</value>
          </attribute>
          <attribute name="max_nodes">
            <data type="integer"/>
          </attribute>
          <attribute name="max_elements">
            <data type="integer"/>
          </attribute>
          <ref name="comment"/>
        </element>
      </element>
      <element name="dynamic_type">
        <a:documentation>Two python scripts must be provided. The script is cycled over each particle.
One script for particle position (output is tuple of position coords)
Second script is for particle radius (output is radius value)
Third script is for particle translational velocity.
Fourth script is for particle angular velocity. (Note: particles 
have a no slip boundary condition at the surface, so this angular velocity
WILL matter to the flow.)
Python functions should be of the form:
def val(X, t):
  Function code
  return # Return value
where X is a tuple of length geometry dimension.
  X[0] contains the number of the particle (in real format)</a:documentation>
        <attribute name="name">
          <value>python_script</value>
        </attribute>
        <element name="geometry_file">
          <attribute name="name">
            <value>gid_mesh2D</value>
          </attribute>
          <attribute name="file_name">
            <data type="string"/>
          </attribute>
          <attribute name="format">
            <value>GiD_2D</value>
          </attribute>
          <attribute name="max_nodes">
            <data type="integer"/>
          </attribute>
          <attribute name="max_elements">
            <data type="integer"/>
          </attribute>
          <ref name="comment"/>
        </element>
        <element name="number_of_particles">
          <ref name="integer"/>
        </element>
        <element name="position_script">
          <ref name="python_code"/>
        </element>
        <element name="translation_velocity_script">
          <ref name="python_code"/>
        </element>
        <element name="angular_position_script">
          <ref name="python_code"/>
        </element>
        <element name="angular_velocity_script">
          <ref name="python_code"/>
        </element>
      </element>
      <element name="dynamic_type">
        <a:documentation>Using femdem 2D to model dynamics. Filename of input file must
be specified.</a:documentation>
        <attribute name="name">
          <value>use_2Dfemdem</value>
        </attribute>
        <attribute name="file_name">
          <data type="string"/>
        </attribute>
        <optional>
          <element name="oneway">
            <empty/>
          </element>
        </optional>
      </element>
    </choice>
  </define>
  <!--
    Select the type of dynamic control to be used
    Note: DEM and FEMDEM require the respective libraries
    to be compiled.
  -->
  <define name="input_solid_dynamics_ext_mesh3D">
    <choice>
      <element name="static_type">
        <a:documentation>Obtain values from input file.
First line of file is free to use (for comments)
Second line must contain the number of particles
Third and fourth line are again for comments.
Following lines include 4 columns, corresponding to 
the particle's x, y, and z positions, followed by an initial angle
of rotation.</a:documentation>
        <attribute name="name">
          <value>from_input_file</value>
        </attribute>
        <attribute name="file_name">
          <data type="string"/>
        </attribute>
        <element name="geometry_file">
          <attribute name="name">
            <value>gid_mesh3D</value>
          </attribute>
          <attribute name="file_name">
            <data type="string"/>
          </attribute>
          <attribute name="format">
            <value>GiD_3D</value>
          </attribute>
          <attribute name="max_nodes">
            <data type="integer"/>
          </attribute>
          <attribute name="max_elements">
            <data type="integer"/>
          </attribute>
          <ref name="comment"/>
        </element>
      </element>
      <element name="static_type">
        <a:documentation>Two python scripts must be provided. The script is cycled over each particle.
One script for particle position (output is tuple of position coords)
The second script sets particle angular position (with respect to original reference)
Python functions should be of the form:
def val(X, t):
  Function code
  return # Return value
where X is a tuple of length geometry dimension.
  X[0] contains the number of the particle (in real format)</a:documentation>
        <attribute name="name">
          <value>python_script</value>
        </attribute>
        <element name="geometry_file">
          <attribute name="name">
            <value>gid_mesh3D</value>
          </attribute>
          <attribute name="file_name">
            <data type="string"/>
          </attribute>
          <attribute name="format">
            <value>GiD_3D</value>
          </attribute>
          <attribute name="max_nodes">
            <data type="integer"/>
          </attribute>
          <attribute name="max_elements">
            <data type="integer"/>
          </attribute>
          <ref name="comment"/>
        </element>
        <element name="number_of_particles">
          <ref name="integer"/>
        </element>
        <element name="position_script">
          <ref name="python_code"/>
        </element>
        <element name="angular_position_script">
          <ref name="python_code"/>
        </element>
      </element>
      <element name="dynamic_type">
        <a:documentation>Obtain values from input file.
First line of file is free to use (for comments)
Second line must contain the number of particles
Third and fourth line are again for comments. 
Following lines include 5 columns, corresponding to 
the particle's x, y, and z positions, angular position,
followed by the z component of angular velocity</a:documentation>
        <attribute name="name">
          <value>from_input_file</value>
        </attribute>
        <attribute name="file_name">
          <data type="string"/>
        </attribute>
        <element name="geometry_file">
          <attribute name="name">
            <value>gid_mesh3D</value>
          </attribute>
          <attribute name="file_name">
            <data type="string"/>
          </attribute>
          <attribute name="format">
            <value>GiD_3D</value>
          </attribute>
          <attribute name="max_nodes">
            <data type="integer"/>
          </attribute>
          <attribute name="max_elements">
            <data type="integer"/>
          </attribute>
          <ref name="comment"/>
        </element>
      </element>
      <element name="dynamic_type">
        <a:documentation>Two python scripts must be provided. The script is cycled over each particle.
One script for particle position (output is tuple of position coords)
Second script is for particle radius (output is radius value)
Third script is for particle translational velocity.
Fourth script is for particle angular velocity. (Note: particles 
have a no slip boundary condition at the surface, so this angular velocity
WILL matter to the flow.)
Python functions should be of the form:
def val(X, t):
  Function code
  return # Return value
where X is a tuple of length geometry dimension.
  X[0] contains the number of the particle (in real format)</a:documentation>
        <attribute name="name">
          <value>python_script</value>
        </attribute>
        <element name="geometry_file">
          <attribute name="name">
            <value>gid_mesh3D</value>
          </attribute>
          <attribute name="file_name">
            <data type="string"/>
          </attribute>
          <attribute name="format">
            <value>GiD_3D</value>
          </attribute>
          <attribute name="max_nodes">
            <data type="integer"/>
          </attribute>
          <attribute name="max_elements">
            <data type="integer"/>
          </attribute>
          <ref name="comment"/>
        </element>
        <element name="number_of_particles">
          <ref name="integer"/>
        </element>
        <element name="position_script">
          <ref name="python_code"/>
        </element>
        <element name="translation_velocity_script">
          <ref name="python_code"/>
        </element>
        <element name="angular_position_script">
          <ref name="python_code"/>
        </element>
        <element name="angular_velocity_script">
          <ref name="python_code"/>
        </element>
      </element>
      <element name="dynamic_type">
        <a:documentation>Using femdem 3D to model dynamics. Filename of input file must
be specified.</a:documentation>
        <attribute name="name">
          <value>use_3Dfemdem</value>
        </attribute>
        <attribute name="file_name">
          <data type="string"/>
        </attribute>
        <optional>
          <element name="oneway">
            <empty/>
          </element>
        </optional>
      </element>
    </choice>
  </define>
  <define name="cap_option">
    <optional>
      <element name="cap_values">
        <a:documentation>Cap the min and max values of this field when using
it as a volume fraction to work out bulk material
properties.
No capping used if not selected.</a:documentation>
        <optional>
          <element name="upper_cap">
            <a:documentation>Set the upper bound on the field.
Defaults to 1 if not set.</a:documentation>
            <ref name="real"/>
          </element>
        </optional>
        <optional>
          <element name="lower_cap">
            <a:documentation>Set the lower bound on the field.
Defaults to 0 if not set.</a:documentation>
            <ref name="real"/>
          </element>
        </optional>
      </element>
    </optional>
  </define>
</grammar>
