\documentclass[a4paper, 11pt]{book}

\usepackage{palatino}

\title{Spud 1.0}

\usepackage{listings}
\usepackage{hyperref,xspace}
\usepackage[margin=2cm]{geometry}
\usepackage{longtable}

\lstloadlanguages{Fortran,C++,C}

\lstdefinelanguage{rnc}
{morekeywords={element,attribute},
  sensitive=false,
  morecomment=[l]{\#},
  morestring=[b]",
}

\newcommand{\fortran}[1]{\framebox{#1}}
\renewcommand{\c}[1]{\framebox{#1}}
\newcommand{\cpp}[1]{\framebox{#1}}

\newcommand{\stat}{\lstinline[language=fortran]+stat+\xspace}

\setlength{\parindent}{0pt}
\setlength{\parskip}{1ex}

\begin{document}
\maketitle

\tableofcontents
\chapter{Installation and building}

\section{Building from source}

Libspud is build using a standard autoconf system. It should be possible to
build libspud and install it in \verb+/usr/local+ simply by typing:

\begin{verbatim}
./configure
make
make install
\end{verbatim}

Installing to an alternative location is possible by specifying the
\verb+--prefix+ option to \verb+configure+. For a full list of configure
options type:

\begin{verbatim}
./configure --help
\end{verbatim}

\section{Debian and Ubuntu packages}

Debian and Ubuntu packages are available from the Applied Modelling and
Computation Group at Imperial College London. The Debian repositiory may be
accessed by adding the following lines to \verb+/etc/apt/sources.list+:

\begin{verbatim}
deb http://amcg.ese.ic.ac.uk/debian/ unstable main contrib non-free
deb-src http://amcg.ese.ic.ac.uk/debian/ unstable main contrib non-free
\end{verbatim}

The Ubuntu repsository may be accessed via the following lines:

\begin{verbatim}
deb http://amcg.ese.ic.ac.uk/debian/ gutsy main contrib non-free
deb-src http://amcg.ese.ic.ac.uk/debian/ gutsy main contrib non-free
\end{verbatim}

The Spud library and the base language are installed by the
\verb+libspud-dev+ package while diamond is shipped in the \verb+diamond+
package. Both packages are built from the \verb+spud+ source package. Binary
packages are supplied for the i386 and amd64 architectures.

After adding the relevant lines to \verb+/etc/apt/sources.list+, install the
packages by typing:

\begin{verbatim}
sudo apt-get update
sudo apt-get install diamond libspud-dev
\end{verbatim}

\chapter{Libspud}

Libspud provides C, C++ and Fortran interfaces for accessing the options
specified in a Spud xml file. 

\section{The options tree}

Spud xml files are read into an in-memory tree structure which reflects the
tree of nested elements in the xml. Nodes in this tree are indexed by
strings so that the options tree is a form of dictionary in which values are
interrogated via keys. 

\section{Option path syntax}

The option key syntax is similar to Unix file path syntax ...

\subsection{Multiple elements}

\subsection{Attributes}

\section{Language specific features}

In some cases the interfaces are differ slightly between Fortran, C and C++.
This is brought about by differences in the designs of these languages
themselves and in particular the difference in the manner in which optional
arguments are supported in Fortran on the one hand and C/C++ on the other.
The decision has been made to write the interfaces in the manner which seems
natural in each language at the cost of consistency between languages rather
than enforcing a foreign paradigm on one or all of the interfaces.

\subsection{Fortran}

All of the Fortran procedures as well as the named constants for data types
(\ref{sec:types}) are encapsulated in the \lstinline+spud+ module.

Where a routine returns an error code, in Fortran this is achieved via the
optional \stat argument. If \stat is not present and an error code other
than \lstinline[language=fortran]+SPUD_NO_ERROR+ is returned then execution
will halt with an error message.

\subsection{C}

Since C does not itself have any namespacing facility, all exposed symbols
have the prefix \lstinline[language=C]+spud_+.

\subsection{C++}

The entire public C++ API of libspud is contained in the
\lstinline[language=C++]+Spud+ namespace.

\section{Naming conventions}

Where a routine returns it's main result via an argument (as is the case for
a Fortran subroutine, for example), the routine's name starts with
\lstinline[language=fortran]+get_+. The word
\lstinline[language=fortran]+key+ is exclusively used to refer to a lookup key in
the options dictionary.

\section{Procedure interfaces}
\lstset{frame=single}

In each case, the Fortran interface is given first, followed by the C and
then C++ interfaces.

\subsection{get\_child\_name}

\begin{lstlisting}[language=fortran]
subroutine get_child_name(key, index, child_name)    
  character(len=*), intent(in)::key 
  integer, intent(in)::index
  character(len=*), intent(out)::child_name
\end{lstlisting}

\begin{lstlisting}[language=C]
int spud_get_child_name(const char* key, const int* key_len, 
  const int* index, 
  char* child_name, const int* child_name_len)
\end{lstlisting}

\begin{lstlisting}[language=C++]
static Spud::OptionError Spud::get_child_name(const std::string& key, 
  const unsigned& index, 
  std::string& child_name)
\end{lstlisting}

Retrieve the name of the \lstinline+index+th child of \lstinline+key+. This
is mostly useful for debugging input files.

\subsection{get\_option}

\begin{lstlisting}[language=fortran,emph=option_type,emphstyle=\textit]
subroutine get_option_real_scalar(key, val, stat, default)
  character(len=*), intent(in) :: key
  option_type, intent(out) :: val
  integer, intent(out), optional :: stat
  option_type, intent(in), optional :: default
\end{lstlisting}

\begin{lstlisting}[language=C,emph=option_type,emphstyle=\textit]
int spud_get_option(const char* key, const int* key_len, void* val)
\end{lstlisting}

\begin{lstlisting}[language=C++,emph=option_type,emphstyle=\textit]
static Spud::OptionError Spud::get_option(const std::string& key, 
option_type val)

static Spud::OptionError Spud::get_option(const std::string& key, 
option_type val, option_type default_val)
\end{lstlisting}


This is the main method for retrieving option values from the options
dictionary. For Fortran and C++ \lstinline[emph=option_type,emphstyle=\textit]+option_type+ can be any of the following values:

\begin{tabular}{ll}
  \textbf{Fortran type} & \textbf{C++ type} \\
   \lstinline[language=fortran]+double precision+ & 
   \lstinline[language=C++]+double&+ \\
   \lstinline[language=fortran]+double precision, dimension(:)+ & 
   \lstinline[language=C++]+std::vector<double>&+ \\
   \lstinline[language=fortran]+double precision, dimension(:,:)+ & 
   \lstinline[language=C++]+std::vector< std::vector<double> >&+\\
   \lstinline[language=fortran]+integer+ & 
   \lstinline[language=C++]+int&+ \\
   \lstinline[language=fortran]+integer, dimension(:)+ & 
   \lstinline[language=C++]+std::vector<int>&+ \\
   \lstinline[language=fortran]+integer, dimension(:,:)+ & 
   \lstinline[language=C++]+std::vector< std::vector<int> >&+\\
   \lstinline[language=fortran]+character(len=*)+ &
   \lstinline[language=C++]+std::string&+
\end{tabular}

In C, the returned argument is always a \lstinline+void+ pointer and it is
the responsibility of the user to match the type correctly.  In every case
the type and shape of the argument must match that of the option in the
dictionary.

In C and C++, the function returns an error code. In Fortran, the error code
is returned via the optional \stat argument. If an error or warning occurs
and the \stat argument has not been set, execution will halt with an
appropriate error message. The fallback behaviour of the routine is as follows:
\begin{itemize}
\item If \lstinline+key+ matches an option but the shape, rank or type fails
  to match, appropriate error  code will be set (see
  \ref{sec:error_codes}). 
\item If \lstinline+key+ fails to match but \lstinline+default+ is present,
  \lstinline+option+ is set to the value of \lstinline+default+.
\item If \lstinline+key+ fails to match and \lstinline+default+ is not
  present, the error code will be set to \lstinline+SPUD_KEY_ERROR+. 
\end{itemize}

\subsection{have\_option}

\begin{lstlisting}[language=fortran]
function have_option(key)
  logical :: have_option
  character(len=*), intent(in) :: key
\end{lstlisting}

\begin{lstlisting}[language=C]
int spud_have_option(const char* key, const int* key_len)
\end{lstlisting}

\begin{lstlisting}[language=C++]
static logical_t Spud::have_option(const std::string& key)
\end{lstlisting}

Returns true if \lstinline+key+ is present in the options
dictionary. This is useful for determining whether optional options have
been set and for determining which of a choice of options has been selected.

\subsection{load\_options}

\begin{lstlisting}[language=fortran]
subroutine load_options(filename) 
  character(len=*), intent(in) :: filename
\end{lstlisting}

\begin{lstlisting}[language=C]
void spud_load_options(const char* key, const int* key_len)
\end{lstlisting}

\begin{lstlisting}
static void Spud::load_options(const std::string& filename)
\end{lstlisting}

Read the xml file \lstinline+filename+ into the options tree.

\subsection{option\_count}

\begin{lstlisting}[language=fortran]
function option_count(key)
  integer :: option_count
  character(len=*), intent(in) :: key
\end{lstlisting}

\begin{lstlisting}[language=C]
int spud_option_count(const char* key, const int* key_len)
\end{lstlisting}

\begin{lstlisting}[language=C++]
static int Spud::option_count(const std::string& key)
\end{lstlisting}

Returns the number of options which match \lstinline+key+. This is
useful where an option can occur any number of times (for example a
simulation may allow for any number of fields to be specified). If
\lstinline+key+ is not present in the dictionary, this returns 0.

\subsection{option\_rank}

\begin{lstlisting}[language=fortran]
function option_rank(key, stat) result (rank)
  integer :: rank
  character(len=*), intent(in) :: key
  integer, intent(out), optional :: stat
\end{lstlisting}

\begin{lstlisting}[language=C]
int spud_get_option_rank(const char* key, const int* key_len, int* rank)
\end{lstlisting}

\begin{lstlisting}[language=C++]
static Spud::OptionError Spud::get_option_rank(const std::string& key, 
int& rank)
\end{lstlisting}

Returns the rank of the option specified by \lstinline+key+. If
\lstinline+key+ is not in the options dictionary then the error code
\lstinline+SPUD_KEY_ERROR+ will be set.

The rank returned will be 0 (for a scalar), 1 (for a vector) or 2 (a rank 2
tensor, or matrix). 

\subsection{option\_shape}

\begin{lstlisting}[language=fortran]
function option_shape(key, stat) result (lshape)
  integer, dimension(2) :: lshape
  character(len=*), intent(in) :: key
  integer, intent(out), optional :: stat
\end{lstlisting}

\begin{lstlisting}[language=C]
int spud_get_option_shape(const char* key, const int* key_len, int* shape)
\end{lstlisting}

\begin{lstlisting}[language=C++]
static Spud::OptionError Spud::get_option_shape(const std::string& key, 
std::vector<int>& shape)
\end{lstlisting}

Return the shape of the option specified by \lstinline+key+. The shape is
always a 2-vector. If the option in question is rank 1 then the second
component will be 0, if the option is rank 0 (a scalar) then both entries
will be 0.

If \lstinline+key+ does not correspond to a valid option, then the error
code \lstinline+SPUD_KEY_ERROR+ will be set.

\subsection{option\_type}\label{sec:option_type}

\begin{lstlisting}[language=fortran]
function option_type(key, stat) result (type)
  integer :: type
  character(len=*), intent(in) :: key
  integer, intent(out), optional :: stat
\end{lstlisting}

\begin{lstlisting}[language=C]
int spud_get_option_type(const char* key, const int* key_len, int* type)  
\end{lstlisting}

Returns the type of the option specified by \lstinline+key+. The type will
be returned as one of the following named constants: 
\lstinline+SPUD_REAL+, \lstinline+SPUD_INTEGER+ and
\lstinline+SPUD_CHARACTER+. 

Note that by default, all reals in Spud are
double precision.

If \lstinline+key+ does not correspond to a valid option, then the error
code \lstinline+SPUD_KEY_ERROR+ will be set.

\subsection{number\_of\_children}

\begin{lstlisting}[language=Fortran]
function number_of_children(key)
  integer :: number_of_children
  character(len=*), intent(in) :: key
\end{lstlisting}

\begin{lstlisting}[language=C]
int spud_number_of_children(const char* key, const int* key_len)
\end{lstlisting}

\begin{lstlisting}[language=C++]
static int Spud::number_of_children(const std::string& key)
\end{lstlisting}

Print the number of children under \lstinline+key+. This is mainly of use
for debugging input files.

\subsection{write\_options}

\begin{lstlisting}[language=fortran]
subroutine write_options(filename) 
  character(len=*), intent(in) :: filename
\end{lstlisting}

\begin{lstlisting}[language=C]
void spud_write_options(const char* filename, const int* filename_len)
\end{lstlisting}

\begin{lstlisting}[language=C++]
static void write_options(const std::string& filename)
\end{lstlisting}

Write the current options tree out to the xml file \lstinline+filename+

\subsection{Error codes}\label{sec:error_codes}

The following values are return statuses of procedures. In Fortran these are
named constants in the \lstinline+spud+ module while in C and C++ these are
the enum types \lstinline+SpudOptionError+ and \lstinline+Spud::OptionError+
respectively. 

Error values are greater than zero, warnings are negative and
\lstinline+SPUD_NO_ERROR+ has the value 0.

\begin{tabular}{lp{8cm}}
  \textbf{Error code} & \textbf{Interpretation}\\
  \lstinline+SPUD_NO_ERROR+ & Returned for successful completion.\\
  \lstinline+SPUD_KEY_ERROR+ & The specified option is not present in the
  dictionary.\\
  \lstinline+SPUD_TYPE_ERROR+ & The specified option has a different type
  from that of the option argument provided.\\
  \lstinline+SPUD_RANK_ERROR+ & The specified option has a different type
  from that of the option argument provided.\\
  \lstinline+SPUD_SHAPE_ERROR+ & The specified option has a different type
  from that of the option argument provided.\\
  \lstinline+SPUD_NEW_KEY_WARNING+ & The option being inserted is not
  already in the dictionary.\\
  \lstinline+SPUD_ATTR_SET_FAILED_WARNING+ & The key being set as an
  attribute already refers to an option.
\end{tabular}

\subsection{Data type parameters}\label{sec:types}

The option\_type routine returns the following values. In Fortran these are
named constants in the \lstinline+spud+ module while in C and C++ these are
the enum types \lstinline+SpudOptionType+ and \lstinline+Spud::OptionType+
respectively. 

\begin{tabular}{ll}
  \textbf{Fortran} & \textbf{C/C++} \\
  \lstinline+SPUD_REAL+ & \lstinline+SPUD_DOUBLE+\\
  \lstinline+SPUD_INTEGER+ & \lstinline+SPUD_INT+\\
  \lstinline+SPUD_NONE+ & \lstinline+SPUD_NONE+\\
  \lstinline+SPUD_CHARACTER+ & \lstinline+SPUD_STRING+
\end{tabular}

\chapter{Spud base language}
\lstset{language=rnc}

The World Wide Web Consortium's Extensible Markup Language (XML) provides a
generic syntax for machine parseable languages.  These allow the
organisation of model input options into a tree of nested elements.
Utilising such a structure within the options file allows distinct groups of
options to be gathered together in branches while suboption dependencies can
be represented as child elements.

\section{RELAX NG}

Spud uses the RELAX NG schema language within the XML system. For full
documentation of RELAX NG see \url{http://relaxng.org/}. The
\href{http://relaxng.org/compact-tutorial-20030326.html}{compact syntax
  tutorial}\ is particularly useful.

The examples presented here are shown in a compact syntax of RELAX NG.  This
is the preferred syntax for editing Spud schemas and the format it is
shipped in.  However the more verbose XML syntax is better supported by
software parsers.  Hence the completed schema, including the base language,
is translated from compact to XML syntax using the software package Trang
before use by Spud based tools like Diamond.


\section{Base language named patterns}
The RELAX NG language allows different schemas to be imported into one
another, which enables Spud to define a base language for schema developers.
The Spud base language thus provides core schema objects (known in RELAX NG
as patterns) that enable generic tools included in Spud to handle low level
data in an elegant manner.

For example the \lstinline *real_dim_symmetric_tensor* pattern is defined below: 
\begin{lstlisting}
# A dim x dim real matrix (rank 2 tensor) constrained to be symmetric.
real_dim_symmetric_tensor =
   (
      element real_value{
         attribute symmetric {"true"},
         attribute rank { "2" },
         # Setting dim1, dim2 to a function of dim allows the gui
         # to set the tensor to the right shape.
         attribute dim1 { "dim" },
         attribute dim2 { "dim" },
         attribute shape { list{xsd:integer, xsd:integer} },
         list {xsd:float+}
      },
      comment
   )
\end{lstlisting}
This core object contains all the information required to define the
properties of a real, symmetric, rank 2 tensor with square dimensions equal
to the physical dimension specified.  This enables Spud based generic tools
to reduce the level of information required as input from the user.  In this
case the user is only required to provide a list of reals to fill out the
tensor while the generic tool will ensure it is symmetric, ordered correctly
and save the rank, shape and dimensions.  Thus from the developers
perspective all the information required to import a symmetric tensor is
available from Spud alongside the user's input.

As can be seen above the principal element of the \lstinline
*real_dim_symmetric_tensor* pattern is \lstinline *real_value*.
Modification of the rank, shape and dimension attributes of this element
allows the Spud based language to be expanded easily to incorporate other
real data structures.  For instance, a rank 1 real vector with length equal
to the physical dimension specified is defined in the \lstinline
*real_dim_vector* pattern:
\begin{lstlisting}
# A real vector of length dim
real_dim_vector =
   (
      element real_value{
         attribute rank { "1" },
         # Setting dim1 to a function of dim allows the gui to set the
         # vector to the right length.
         attribute dim1 { "dim" },
         attribute shape { xsd:integer },
         list{xsd:float+}
      },
      comment
   )
\end{lstlisting}

Similar extensions can be made for an integer based \lstinline *integer_value* element, while a \lstinline *string_value* element allows the definition of several character patterns known to Spud generic tools (such as the \lstinline *comment* pattern seen in the examples above).  This allows for the definition of the full Spud base language as follows:

\noindent\begin{longtable}{lp{8cm}}
\lstinline *comment* & A string value that allows users to annotate their input throughout the XML tree structure.  Included in all Spud base language patterns. \\
\lstinline *anystring* & A string value for the input of any generic character string required in the options tree.  Suggests a display of 1 line within Spud based tools such as Diamond. \\
\lstinline *filename* & A string value for the input of filenames in the options tree.  Allows the use of a file selector and suggests a display of 1 line within Spud based tools such as Diamond. \\
\lstinline *python_code* & A string value for the input of python code into the options tree.  Suggests a display of 20 lines within Spud based tools such as Diamond. \\
\lstinline *integer* & An integer value of rank 0 and length 1. \\
\lstinline *integer_vector* & A rank 1 vector of integers of arbitrary length.  Spud tools record the shape of the input. \\
\lstinline *integer_tensor* & A tensor of integers of arbitrary dimensions.  Spud tools record the shape of the input. \\
\lstinline *integer_dim_vector* & A rank 1 vector of integers with length equal to the physical dimension specified. \\
\lstinline *integer_dim_minus_one_vector* & A rank 1 vector of integers with length equal to 1 less than the physical dimension specified. \\
\lstinline *integer_dim_tensor* & A rank 2 tensor of integers with square dimensions equal to the physical dimension specified. \\
\lstinline *integer_dim_symmetric_tensor* & A rank 2 symmetric tensor of integers with square dimensions equal to the physical dimension specified. \\
\lstinline *integer_dim_minus_one_tensor* & A rank 2 tensor of integers with square dimensions equal to 1 less than the physical dimension specified. \\
\lstinline *integer_dim_minus_one_symmetric_tensor* & A rank 2 symmetric tensor of integers with square dimensions equal to 1 less than the physical dimension specified. \\
\lstinline *real* & A real value of rank 0 and length 1. \\
\lstinline *real_vector* & A rank 1 vector of reals of arbitrary length.  Spud tools record the shape of the input. \\
\lstinline *real_tensor* & A rank 2 tensor of reals of arbitrary dimensions.  Spud tools record the shape of the input. \\
\lstinline *real_dim_vector* & A rank 1 vector of reals with length equal to the physical dimension specified. \\
\lstinline *real_dim_minus_one_vector* & A rank 1 vector of reals with length equal to 1 less than the physical dimension specified. \\
\lstinline *real_dim_tensor* & A rank 2 tensor of reals with square dimensions equal to the physical dimension specified. \\
\lstinline *real_dim_symmetric_tensor* & A rank 2 tensor of reals with square dimensions equal to the physical dimension specified. \\
\lstinline *real_dim_minus_one_tensor* & A rank 2 tensor of reals with square dimensions equal to 1 less than the physical dimension specified. \\
\lstinline *real_dim_minus_one_symmetric_tensor* & A rank 2 tensor of reals with square dimensions equal to 1 less than the physical dimension specified.
\end{longtable}

\subsection{String data}

\subsection{Symetric tensors}

\section{The base element}

\section{Specifying problem dimension }

\section{Restrictions on the base language}

\section{Comments and annotations}

\chapter{Diamond}

\section{Installation}
Diamond depends on Python (version 2.3 or greater), PyGTK,
the 4Suite XML library, and the lxml library. All of these dependencies
are available in the Debian/Ubuntu repositories with the following command:
\begin{verbatim}
apt-get install python-gtk2 python-lxml python-4suite-xml
\end{verbatim}

Windows versions of these packages are available for download on their respective websites.

\section{Configuration files}

In accordance with normal Unix practice, system wide configuration for
diamond is stored in the \verb+/etc/diamond+ directory while per-user
configuration is stored in a \verb+.diamond+ directory in the user's home
directory.

\subsection{Schemas}

Diamond needs to know which Spud schemas are installed and available on the
current system. This is specified in the \verb+schemata+ subdirectory of the
\verb+/etc/diamond+ and \verb+~/.diamond+ directories. The file names in the
\verb+schemata+ directory give the filename extension associated with a
particular problem description language. The content of the file is two
lines. The first line is the name of the problem description language while
the second line contains the path of the xml syntax (\verb+.rng+) version of
the corresponding schema. 

For example, the Fluidity package has a problem description language called
the Fluidity Markup Language which uses the file extension
\verb+.flml+. When installed on a system by the sysadmin, Fluidity might
create the file \verb+/etc/diamond/flml+ with the following contents:
\begin{verbatim}
Fluidity Markup Language
/usr/share/fluidity/fluidity_options.rng
\end{verbatim}
An individual user \verb+jrluser+ might have the current version of the
Fluidity svn tree checked out in their home directory and would need to
point diamond at the (posssibly updated) schema in their source
tree. \verb+jrluser+ would then create the file
\verb+/home/jrluser/.diamond/schemata/flml+ which would contain:
\begin{verbatim}
Fluidity Markup Language
/home/jrluser/fluidity/tools/fluidity_options.rng
\end{verbatim}
Now Diamond will pick up the version of the schema in \verb+jrluser+'s svn
tree rather than the version the sysadmin installed.

\subsection{Running Diamond}

Diamond can be started in several ways.

When executed as
\begin{verbatim}
diamond
\end{verbatim}
Diamond will offer the user the choice of which registered schema to use.
If only one schema is registered, then it will use that by default.
Diamond will open a blank document of the language specified by the schema to be edited.

When executed as
\begin{verbatim}
diamond -s /path/to/schema.rng
\end{verbatim}
Diamond will open a blank document using the schema specified on the command line.

When executed as
\begin{verbatim}
diamond filename.suffix
\end{verbatim}
Diamond will inspect the registered schemas for the suffix specified
and use that schema.

\subsection{Dynamic validation}
Diamond uses the schema to guide the editing of valid documents that the schema
permits. When a blank document is opened, information necessary to make a valid
document is missing and the document is thus invalid\footnote{This is true for all
but a trivial schema which permits only one document.}. The invalidity of the document
is reflected in the colouration of the root node: valid nodes are coloured in black,
while invalid nodes are coloured in blue. As invalid nodes have their attributes
and data specified, their validity is dynamically updated and they are coloured appropriately.
The document as a whole is valid if and only if the root node is coloured black.

\end{document}
