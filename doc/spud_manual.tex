\documentclass[a4paper, 11pt]{book}

\usepackage{palatino}

\title{Spud 1.0}

\usepackage{listings}
\usepackage{hyperref}
\usepackage[margin=2cm]{geometry}


\lstloadlanguages{Fortran,C++,C}

\lstdefinelanguage{rnc}
{morekeywords={element,attribute},
  sensitive=false,
  morecomment=[l]{\#},
  morestring=[b]",
}


\begin{document}
\maketitle

\tableofcontents
\chapter{Installation and building}

\chapter{Libspud}

Libspud provides C, C++ and Fortran interfaces for accessing the options
specified in a Spud xml file. 

\section{The options tree}

\section{Language specific features}

\section{Fortran module}

All of the Fortran procedures as well as the named constants for data types
(\ref{sec:types}) 

\section{Procedure interfaces}
\lstset{language=Fortran}

\subsection{get\_child\_name}

\begin{lstlisting}[language=fortran]
subroutine get_child_name(key, index, child_name)    
  character(len=*), intent(in)::key 
  integer, intent(in)::index
  character(len=*), intent(out)::child_name
\end{lstlisting}

\begin{lstlisting}[language=C]
int spud_get_child_name(const char* key, const int* key_len, 
  const int* index, 
  char* child_name, const int* child_name_len)
\end{lstlisting}

\begin{lstlisting}[language=C++]
Spud::OptionError Spud::get_child_name(const std::string& key, 
  const unsigned& index, 
  std::string& child_name); 
\end{lstlisting}

Retrieve the name of the \lstinline+index+th child of \lstinline+key+. This
is mostly useful for debugging input files.

\subsection{get\_option}

\begin{lstlisting}[language=fortran,emph=option_type,emphstyle=\textit]
subroutine get_option_real_scalar(key, option, stat, default)
  character(len=*), intent(in) :: key
  option_type, intent(out) :: option
  integer, intent(out), optional :: stat
  option_type, intent(in), optional :: default
\end{lstlisting}

\begin{lstlisting}[language=C,emph=option_type,emphstyle=\textit]
int spud_get_option(const char* key, const int* key_len, void* val);
\end{lstlisting}

\begin{lstlisting}[language=C++,emph=option_type,emphstyle=\textit]
Spud::OptionError Spud::get_option(const std::string& key, option_type);
\end{lstlisting}

This is the main method for retrieving option values from the options
dictionary. \lstinline[emph=option_type,emphstyle=\textit]+option_type+ can
be any of \lstinline+real+, \lstinline+integer+ or
\lstinline+character+ and \lstinline+real+ or \lstinline+integer+ arguments can be
scalars or rank 1 or 2 arrays. In every case the type and shape of the
argument must match that of the option in the dictionary.

The fallback behaviour of the routine is as follows:
\begin{itemize}
\item If \lstinline+key+ matches an option but the shape, rank or type fails
  to match, the stat argument will be set to the appropriate error (see
  \ref{sec:error_codes}). If the \lstinline+stat+ argument is absent then execution
  will halt with an error.
\item If \lstinline+key+ fails to match but \lstinline+default+ is present,
  \lstinline+option+ is set to the value of \lstinline+default+.
\item If \lstinline+key+ fails to match and \lstinline+default+ is not
  present, \lstinline+stat+ will be set to \lstinline+SPUD_KEY_ERROR+. If
  \lstinline+stat+ is not present then execution will cease with an error.
\end{itemize}

\subsection{have\_option}

\begin{lstlisting}
function have_option(key)
  logical :: have_option
  character(len=*), intent(in) :: key
\end{lstlisting}

Returns true if \lstinline+key+ is present in the options
dictionary. This is useful for determining whether optional options have
been set and for determining which of a choice of options has been selected.

\subsection{load\_options}

\begin{lstlisting}
subroutine load_options(filename) 
  character(len=*), intent(in) :: filename
\end{lstlisting}

Read the xml file \lstinline+filename+ into the options tree.

\subsection{option\_count}

\begin{lstlisting}
function option_count(key)
  integer :: option_count
  character(len=*), intent(in) :: key
\end{lstlisting}

Returns the number of options which match \lstinline+key+. This is
useful where an option can occur any number of times (for example a
simulation may allow for any number of fields to be specified). If
\lstinline+key+ is not present in the dictionary, this returns 0.

\subsection{option\_rank}

\begin{lstlisting}
function option_rank(key, stat) result (rank)
  integer :: rank
  character(len=*), intent(in) :: key
  integer, intent(out), optional :: stat
\end{lstlisting}

Returns the rank of the option specified by \lstinline+key+. If
\lstinline+key+ does not correspond to a valid option, then if
\lstinline+stat+ is present it will be set to \lstinline+SPUD_KEY_ERROR+ and
if \lstinline+stat+ is not present, execution will halt with an error.

The rank returned will be 0 (for a scalar), 1 (for a vector) or 2 (a rank 2
tensor, or matrix). 

\subsection{option\_shape}

\begin{lstlisting}
function option_shape(key, stat) result (lshape)
  integer, dimension(2) :: lshape
  character(len=*), intent(in) :: key
  integer, intent(out), optional :: stat
\end{lstlisting}

Return the shape of the option specified by \lstinline+key+. The shape is
always a 2-vector. If the option in question is rank 1 then the second
component will be 0, if the option is rank 0 (a scalar) then both entries
will be 0.

 If \lstinline+key+ does not correspond to a valid option, then if
 \lstinline+stat+ is present it will be set to \lstinline+SPUD_KEY_ERROR+ and
 if \lstinline+stat+ is not present, execution will halt with an error.

\subsection{option\_type}\label{sec:option_type}

\begin{lstlisting}
function option_type(key, stat) result (type)
  integer :: type
  character(len=*), intent(in) :: key
  integer, intent(out), optional :: stat
\end{lstlisting}

Returns the type of the option specified by \lstinline+key+. The type will
be returned as one of the following named constants: 
\lstinline+SPUD_REAL+, \lstinline+SPUD_INTEGER+ and
\lstinline+SPUD_CHARACTER+. Note that by default, all reals in Spud are
double precision.

If \lstinline+key+ does not correspond to a valid option, then if
\lstinline+stat+ is present it will be set to \lstinline+SPUD_KEY_ERROR+ and
if \lstinline+stat+ is not present, execution will halt with an error.

\subsection{number\_of\_children}

\begin{lstlisting}
function number_of_children(key)
  integer :: number_of_children
  character(len=*), intent(in) :: key
\end{lstlisting}

Print the number of children under \lstinline+key+. This is mainly of use
for debugging input files.

\subsection{write\_options}

\begin{lstlisting}
subroutine write_options(filename) 
  character(len=*), intent(in) :: filename
\end{lstlisting}

Write the current options tree out to the xml file \lstinline+filename+

\subsection{Error codes}\label{sec:error_codes}

The following values are return statuses of procedures. In Fortran these are
named constants in the \lstinline+spud+ module while in C and C++ these are
the enum types \lstinline+SpudOptionError+ and \lstinline+Spud::OptionError+
respectively. 

Error values are greater than zero, warnings are negative and
\lstinline+SPUD_NO_ERROR+ has the value 0.

\begin{tabular}{lp{8cm}}
  \textbf{Error code} & \textbf{Interpretation}\\
  \lstinline+SPUD_NO_ERROR+ & Returned for successful completion.\\
  \lstinline+SPUD_KEY_ERROR+ & The specified option is not present in the
  dictionary.\\
  \lstinline+SPUD_TYPE_ERROR+ & The specified option has a different type
  from that of the option argument provided.\\
  \lstinline+SPUD_RANK_ERROR+ & The specified option has a different type
  from that of the option argument provided.\\
  \lstinline+SPUD_SHAPE_ERROR+ & The specified option has a different type
  from that of the option argument provided.\\
  \lstinline+SPUD_NEW_KEY_WARNING+ & The option being inserted is not
  already in the dictionary.\\
  \lstinline+SPUD_ATTR_SET_FAILED_WARNING+ & The key being set as an
  attribute already refers to an option.
\end{tabular}

\subsection{Data type parameters}\label{sec:types}

The option\_type routine returns the following values. In Fortran these are
named constants in the \lstinline+spud+ module while in C and C++ these are
the enum types \lstinline+SpudOptionType+ and \lstinline+Spud::OptionType+
respectively. 

\begin{tabular}{ll}
  \textbf{Fortran} & \textbf{C/C++} \\
  \lstinline+SPUD_REAL+ & \lstinline+SPUD_DOUBLE+\\
  \lstinline+SPUD_INTEGER+ & \lstinline+SPUD_INT+\\
  \lstinline+SPUD_NONE+ & \lstinline+SPUD_NONE+\\
  \lstinline+SPUD_CHARACTER+ & \lstinline+SPUD_STRING+
\end{tabular}

\section{C++ interface}
\lstset{language=C++}

\chapter{Spud base language}
\lstset{language=rnc}

The World Wide Web Consortium's Extensible Markup Language (XML) provides a generic syntax for machine parseable languages.  These allow the organisation of model input options into a tree of nested elements.  Utilising such a structure within the options file allows distinct groups of options to be gathered together in branches while suboption dependencies can be  represented as child elements.

Spud uses the RELAX NG schema language within the XML system.  The RELAX NG language allows different schemas to be imported into one another, which enables Spud to define a base language for schema developers.  The Spud base language thus provides core schema objects (known in RELAX NG as patterns) that enable generic tools included in Spud to handle low level data in an elegant manner.

For example the \lstinline *real_dim_symmetric_tensor* pattern is defined below: 
\begin{lstlisting}
# A dim x dim real matrix (rank 2 tensor) constrained to be symmetric.
real_dim_symmetric_tensor =
   (
      element real_value{
         attribute symmetric {"true"},
         attribute rank { "2" },
         # Setting dim1, dim2 to a function of dim allows the gui to set the
         # tensor to the right shape.
         attribute dim1 { "dim" },
         attribute dim2 { "dim" },
         attribute shape { list{xsd:integer, xsd:integer} },
         list {xsd:float+}
      },
      comment
   )
\end{lstlisting}
This core object contains all the information required to define the properties of a real, symmetric, rank 2 tensor with square dimensions equal to the physical dimension specified.  This enables Spud based generic tools to reduce the level of information required as input from the user.  In this case the user is only required to provide a list of reals to fill out the tensor while the generic tool will ensure it is symmetric, ordered correctly and save the rank, shape and dimensions.  Thus from the developers perspective all the information required to import a symmetric tensor is available from Spud alongside the user's input.

As can be seen above the principal element of the \lstinline *real_dim_symmetric_tensor* pattern is \lstinline *real_value*.  Modification of the rank, shape and dimension attributes of this element allows the Spud based language to be expanded easily to incorporate other real data structures.  For instance, a rank 1 real vector with length equal to the physical dimension specified is defined in the \lstinline *real_dim_vector* pattern:
\begin{lstlisting}
# A real vector of length dim
real_dim_vector =
   (
      element real_value{
         attribute rank { "1" },
         # Setting dim1 to a function of dim allows the gui to set the
         # vector to the right length.
         attribute dim1 { "dim" },
         attribute shape { xsd:integer },
         list{xsd:float+}
      },
      comment
   )
\end{lstlisting}

Similar extensions can be made for an integer based \lstinline *integer_value* element, while a \lstinline *string_value* element allows the definition of several character patterns known to Spud generic tools (such as the \lstinline *comment* pattern seen in the examples above).  This allows for the definition of the full Spud base language as follows:

\noindent\begin{tabular}{lp{8cm}}
\lstinline *comment* & A string value that allows users to annotate their input throughout the XML tree structure.  Included in all Spud base language patterns. \\
\lstinline *anystring* & A string value for the input of any generic character string required in the options tree.  Suggests a display of 1 line within Spud based tools such as Diamond. \\
\lstinline *filename* & A string value for the input of filenames in the options tree.  Allows the use of a file selector and suggests a display of 1 line within Spud based tools such as Diamond. \\
\lstinline *python_code* & A string value for the input of python code into the options tree.  Suggests a display of 20 lines within Spud based tools such as Diamond. \\
\lstinline *integer* & An integer value of rank 0 and length 1. \\
\lstinline *integer_vector* & A rank 1 vector of integers of arbitrary length.  Spud tools record the shape of the input. \\
\lstinline *integer_tensor* & A tensor of integers of arbitrary dimensions.  Spud tools record the shape of the input. \\
\lstinline *integer_dim_vector* & A rank 1 vector of integers with length equal to the physical dimension specified. \\
\lstinline *integer_dim_minus_one_vector* & A rank 1 vector of integers with length equal to 1 less than the physical dimension specified. \\
\lstinline *integer_dim_tensor* & A rank 2 tensor of integers with square dimensions equal to the physical dimension specified. \\
\lstinline *integer_dim_symmetric_tensor* & A rank 2 symmetric tensor of integers with square dimensions equal to the physical dimension specified. \\
\lstinline *integer_dim_minus_one_tensor* & A rank 2 tensor of integers with square dimensions equal to 1 less than the physical dimension specified. \\
\lstinline *integer_dim_minus_one_symmetric_tensor* & A rank 2 symmetric tensor of integers with square dimensions equal to 1 less than the physical dimension specified. \\
\lstinline *real* & A real value of rank 0 and length 1. \\
\lstinline *real_vector* & A rank 1 vector of reals of arbitrary length.  Spud tools record the shape of the input. \\
\lstinline *real_tensor* & A rank 2 tensor of reals of arbitrary dimensions.  Spud tools record the shape of the input. \\
\lstinline *real_dim_vector* & A rank 1 vector of reals with length equal to the physical dimension specified. \\
\lstinline *real_dim_minus_one_vector* & A rank 1 vector of reals with length equal to 1 less than the physical dimension specified. \\
\lstinline *real_dim_tensor* & A rank 2 tensor of reals with square dimensions equal to the physical dimension specified. \\
\lstinline *real_dim_symmetric_tensor* & A rank 2 tensor of reals with square dimensions equal to the physical dimension specified. \\
\lstinline *real_dim_minus_one_tensor* & A rank 2 tensor of reals with square dimensions equal to 1 less than the physical dimension specified. \\
\lstinline *real_dim_minus_one_symmetric_tensor* & A rank 2 tensor of reals with square dimensions equal to 1 less than the physical dimension specified.
\end{tabular}

The examples presented above are shown in a compact syntax of RELAX NG.  This is the preferred syntax for editing Spud schemas and the format it is shipped in.   However the more verbose XML syntax is better supported by software parsers.  Hence the completed schema, including the base language, is translated from compact to XML syntax using the software package Trang before use by Spud based tools like Diamond.

\chapter{Diamond}

\section{Configuration files}

In accordance with normal Unix practice, system wide configuration for
diamond is stored in the \verb+/etc/diamond+ directory while per-user
configuration is stored in a \verb+.diamond+ directory in the user's home
directory.

\subsection{Schemas}

Diamond needs to know which Spud schemas are installed and available on the
current system. This is specified in the \verb+schemata+ subdirectory of the
\verb+/etc/diamond+ and \verb+~/.diamond+ directories. The file names in the
\verb+schemata+ directory give the filename extension associated with a
particular problem description language. The content of the file is two
lines. The first line is the name of the problem description language while
the second line contains the path of the xml syntax (\verb+.rng+) version of
the corresponding schema. 

For example, the Fluidity package has a problem description language called
the Fluidity Markup Language which uses the file extension
\verb+.flml+. When installed on a system by the sysadmin, Fluidity might
create the file \verb+/etc/diamond/flml+ with the following contents:
\begin{verbatim}
Fluidity Markup Language
/usr/share/fluidity/fluidity_options.rng
\end{verbatim}
An individual user \verb+jrluser+ might have the current version of the
Fluidity svn tree checked out in their home directory and would need to
point diamond at the (posssibly updated) schema in their source
tree. \verb+jrluser+ would then create the file
\verb+/home/jrluser/.diamond/schemata/flml+ which would contain:
\begin{verbatim}
Fluidity Markup Language
/home/jrluser/fluidity/tools/fluidity_options.rng
\end{verbatim}
Now Diamond will pick up the version of the schema in \verb+jrluser+'s svn
tree rather than the version the sysadmin installed.

\end{document}
